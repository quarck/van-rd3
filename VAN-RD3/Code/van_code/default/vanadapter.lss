
vanadapter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b34  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000302  00800060  00800060  00000ba8  2**0
                  ALLOC
  2 .debug_aranges 00000040  00000000  00000000  00000ba8  2**3
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000001a5  00000000  00000000  00000be8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000e94  00000000  00000000  00000d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000003d9  00000000  00000000  00001c21  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00001116  00000000  00000000  00001ffa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000150  00000000  00000000  00003110  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000002ae  00000000  00000000  00003260  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000034f  00000000  00000000  0000350e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000108  00000000  00000000  0000385d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	99 c0       	rjmp	.+306    	; 0x134 <__ctors_end>
   2:	a8 c0       	rjmp	.+336    	; 0x154 <__bad_interrupt>
   4:	a7 c0       	rjmp	.+334    	; 0x154 <__bad_interrupt>
   6:	a6 c0       	rjmp	.+332    	; 0x154 <__bad_interrupt>
   8:	a5 c0       	rjmp	.+330    	; 0x154 <__bad_interrupt>
   a:	a4 c0       	rjmp	.+328    	; 0x154 <__bad_interrupt>
   c:	a3 c0       	rjmp	.+326    	; 0x154 <__bad_interrupt>
   e:	a2 c0       	rjmp	.+324    	; 0x154 <__bad_interrupt>
  10:	a1 c0       	rjmp	.+322    	; 0x154 <__bad_interrupt>
  12:	a0 c0       	rjmp	.+320    	; 0x154 <__bad_interrupt>
  14:	9f c0       	rjmp	.+318    	; 0x154 <__bad_interrupt>
  16:	9e c0       	rjmp	.+316    	; 0x154 <__bad_interrupt>
  18:	9d c0       	rjmp	.+314    	; 0x154 <__bad_interrupt>
  1a:	9c c0       	rjmp	.+312    	; 0x154 <__bad_interrupt>
  1c:	9b c0       	rjmp	.+310    	; 0x154 <__bad_interrupt>
  1e:	9a c0       	rjmp	.+308    	; 0x154 <__bad_interrupt>
  20:	99 c0       	rjmp	.+306    	; 0x154 <__bad_interrupt>
  22:	98 c0       	rjmp	.+304    	; 0x154 <__bad_interrupt>
  24:	97 c0       	rjmp	.+302    	; 0x154 <__bad_interrupt>

00000026 <__c.1538>:
  26:	0d 0a 0d 0a 2d 2d 2d 2d 2d 2d 2d 2d 2d 0d 0a 56     ....---------..V
  36:	41 4e 20 6d 6f 6e 69 6e 6f 72 28 72 65 76 31 29     AN moninor(rev1)
  46:	20 6d 65 6e 75 3a 0d 0a 64 20 2d 20 64 75 6d 70      menu:..d - dump
  56:	20 56 41 4e 20 62 75 73 0d 0a 32 20 2d 20 73 65      VAN bus..2 - se
  66:	6e 64 20 27 73 77 69 74 63 68 20 74 6f 20 69 6e     nd 'switch to in
  76:	74 65 72 6e 61 6c 20 43 44 27 20 63 6d 64 0d 0a     ternal CD' cmd..
  86:	33 20 2d 20 73 65 6e 64 20 27 73 77 69 74 63 68     3 - send 'switch
  96:	20 74 6f 20 72 61 64 69 6f 27 20 63 6d 64 0d 0a      to radio' cmd..
  a6:	34 20 2d 20 73 65 6e 64 20 27 73 77 69 74 63 68     4 - send 'switch
  b6:	20 74 6f 20 63 64 20 63 68 61 6e 67 65 72 27 20      to cd changer' 
  c6:	63 6d 64 0d 0a 6d 20 2d 20 6d 6f 6e 69 74 6f 72     cmd..m - monitor
  d6:	20 6c 69 6e 65 20 77 69 74 68 20 74 69 6d 65 72      line with timer
  e6:	0d 0a 70 20 2d 20 55 53 41 52 54 20 70 65 72 66     ..p - USART perf
  f6:	6f 72 6d 61 6e 63 65 20 74 65 73 74 20 28 77 69     ormance test (wi
 106:	6c 6c 20 66 6c 6f 6f 64 20 77 69 74 68 20 63 68     ll flood with ch
 116:	61 72 73 29 0d 0a 72 20 2d 20 72 65 73 65 74 20     ars)..r - reset 
 126:	64 65 76 69 63 65 0d 0a 0d 0a 3e 20 00 00           device....> ..

00000134 <__ctors_end>:
 134:	11 24       	eor	r1, r1
 136:	1f be       	out	0x3f, r1	; 63
 138:	cf e5       	ldi	r28, 0x5F	; 95
 13a:	d4 e0       	ldi	r29, 0x04	; 4
 13c:	de bf       	out	0x3e, r29	; 62
 13e:	cd bf       	out	0x3d, r28	; 61

00000140 <__do_clear_bss>:
 140:	13 e0       	ldi	r17, 0x03	; 3
 142:	a0 e6       	ldi	r26, 0x60	; 96
 144:	b0 e0       	ldi	r27, 0x00	; 0
 146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
 148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
 14a:	a2 36       	cpi	r26, 0x62	; 98
 14c:	b1 07       	cpc	r27, r17
 14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
 150:	5d d1       	rcall	.+698    	; 0x40c <main>
 152:	ee c4       	rjmp	.+2524   	; 0xb30 <_exit>

00000154 <__bad_interrupt>:
 154:	55 cf       	rjmp	.-342    	; 0x0 <__vectors>

00000156 <tx_packet>:
 Arguments:
	r24:r25 -- rxb buffer address
	r22: -- buffer data length
*/

	push 	r15
 156:	ff 92       	push	r15
	push 	r16
 158:	0f 93       	push	r16
	push 	r17
 15a:	1f 93       	push	r17
	push 	r18
 15c:	2f 93       	push	r18
	push 	r19
 15e:	3f 93       	push	r19
	push 	r20
 160:	4f 93       	push	r20
	push 	r21
 162:	5f 93       	push	r21
	push	r30
 164:	ef 93       	push	r30
	push 	r31
 166:	ff 93       	push	r31

	clr 	result
 168:	55 27       	eor	r21, r21
	ldi		max_retry, lo8(255) 
 16a:	3f ef       	ldi	r19, 0xFF	; 255

0000016c <wait_line_idle>:

// wait for the line to be idle for at least 12-13 TS (EOF + IFS)
wait_line_idle:
	// setup sending parameters -- loop cnt, and data ptr
	mov		LOOP_CNT, r22
 16c:	06 2f       	mov	r16, r22
	movw	r30,r24
 16e:	fc 01       	movw	r30, r24

	in 		tmp_reg1, TCNT0 	// read timer value
 170:	12 b7       	in	r17, 0x32	; 50
	ldi		tmp_reg2, 13
 172:	2d e0       	ldi	r18, 0x0D	; 13
	add		tmp_reg1, tmp_reg2	// will wait up to 13 TS from now
 174:	12 0f       	add	r17, r18

00000176 <line_idle_check>:
line_idle_check:
#ifdef SIMULATOR_DEBUG
	sbis	RXD_PORT, RXD_PIN   	// check, if it is zero
#else
	sbic	RXD_PORT, RXD_PIN   	// check, if it is zero
 176:	87 99       	sbic	0x10, 7	; 16
#endif
	rjmp 	line_ok			// if current line st == 1
 178:	05 c0       	rjmp	.+10     	; 0x184 <line_ok>
	clr		tmp_reg1		// line is 0,  update timer, 
 17a:	11 27       	eor	r17, r17
	out 	TCNT0, tmp_reg1		// 
 17c:	12 bf       	out	0x32, r17	; 50

0000017e <to_next_line_idle>:
to_next_line_idle:
	dec 	max_retry		
 17e:	3a 95       	dec	r19
	brne	wait_line_idle
 180:	a9 f7       	brne	.-22     	; 0x16c <wait_line_idle>
	rjmp	fn_return_fail_2	// than -- return "line busy"
 182:	4e c0       	rjmp	.+156    	; 0x220 <fn_return_fail_2>

00000184 <line_ok>:
									
line_ok:	
	in 		tmp_reg2, TCNT0 	// read current timer
 184:	22 b7       	in	r18, 0x32	; 50
	cp		tmp_reg1, tmp_reg2
 186:	12 17       	cp	r17, r18
	brne	line_idle_check		// if we are not reached 13 TS
 188:	b1 f7       	brne	.-20     	; 0x176 <line_idle_check>

	// send preamble first
	// format extra 'fake' byte for preamble, and increment real cnt, so send 
	// preamble as a part of message
	// preamble is 000 01 111 01, this encodes 0x0e byte with E-Man
	ldi		current_byte, lo8(0x0e)
 18a:	4e e0       	ldi	r20, 0x0E	; 14
	inc		LOOP_CNT
 18c:	03 95       	inc	r16
	rjmp 	next_byte_preloaded
 18e:	01 c0       	rjmp	.+2      	; 0x192 <next_byte_preloaded>

00000190 <next_byte>:

	// transmit message body:

next_byte:
	ld 		current_byte, Z+ 	// 2 clks
 190:	41 91       	ld	r20, Z+

00000192 <next_byte_preloaded>:
next_byte_preloaded:
	ldi		tmp_reg2, lo8(10) 	//  1 clk; val= 8 bits plus 2 man bits
 192:	2a e0       	ldi	r18, 0x0A	; 10
	rjmp	skip_delay_next_bit
 194:	05 c0       	rjmp	.+10     	; 0x1a0 <skip_delay_next_bit>

00000196 <next_bit>:

next_bit:
	rjmp 1f 
 196:	00 c0       	rjmp	.+0      	; 0x198 <next_bit+0x2>
	...

0000019a <next_bit_skip_3clk>:
1: 	nop
next_bit_skip_3clk:
	rjmp 1f
 19a:	00 c0       	rjmp	.+0      	; 0x19c <next_bit_skip_3clk+0x2>
1:	rjmp 2f
 19c:	00 c0       	rjmp	.+0      	; 0x19e <next_bit_skip_3clk+0x4>
2:	rjmp 3f
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <skip_delay_next_bit>

000001a0 <skip_delay_next_bit>:
3:

skip_delay_next_bit:
	sbrc 	current_byte, 7		// 1 clk if no skip, 2 clk if skip
 1a0:	47 fd       	sbrc	r20, 7
	rjmp 	aa7					// always 2 clk
 1a2:	03 c0       	rjmp	.+6      	; 0x1aa <aa7>
	nop 
 1a4:	00 00       	nop
	rcall 	orbitary_transmit_0	// 95 clk
 1a6:	40 d0       	rcall	.+128    	; 0x228 <orbitary_transmit_0>
	rjmp 	bb7					// 2 clk
 1a8:	03 c0       	rjmp	.+6      	; 0x1b0 <bb7>

000001aa <aa7>:
aa7: 
	rcall 	orbitary_transmit_1	// 95 clk
 1aa:	46 d0       	rcall	.+140    	; 0x238 <orbitary_transmit_1>
	nop
 1ac:	00 00       	nop
	...

000001b0 <bb7>:
	nop
bb7:
	ldi 	tmp_reg1,3			// 1
 1b0:	13 e0       	ldi	r17, 0x03	; 3

000001b2 <cc7>:
cc7:
	dec 	tmp_reg1			// 1
 1b2:	1a 95       	dec	r17
	brne 	cc7					// 1 if false, 2 if true
 1b4:	f1 f7       	brne	.-4      	; 0x1b2 <cc7>

	// so, the following checks are always takes 4+4+4 clks, not depending on the way, 
	// how the code is executed
	// (not including out of big look cheks)
	
	cpi		tmp_reg2, lo8(7)	// 1 clkk
 1b6:	27 30       	cpi	r18, 0x07	; 7
	breq 	do_man_bit_high		// 2 if branched, 1 if not
 1b8:	59 f0       	breq	.+22     	; 0x1d0 <do_man_bit_high>
	nop							// so, if not -- add one extra
 1ba:	00 00       	nop
	cpi		tmp_reg2, lo8(2)	// 1 clk
 1bc:	22 30       	cpi	r18, 0x02	; 2
	breq	do_man_bit			// 2 clk if branched, 1 if not
 1be:	71 f0       	breq	.+28     	; 0x1dc <do_man_bit>
	nop							// so, if not -- add 1 clk,
 1c0:	00 00       	nop

	lsl		current_byte 		// 1 clk
 1c2:	44 0f       	add	r20, r20
	dec		tmp_reg2			// 1 clk
 1c4:	2a 95       	dec	r18
	brne	next_bit			// 2 if branched, 1 if not
 1c6:	39 f7       	brne	.-50     	; 0x196 <next_bit>

	// out of big loops checks:
	dec 	LOOP_CNT		// 1 clks
 1c8:	0a 95       	dec	r16
	breq 	outloop			// 1 clks if false
 1ca:	71 f0       	breq	.+28     	; 0x1e8 <outloop>
	nop
 1cc:	00 00       	nop
	rjmp 	next_byte		// 2 clks , and 2 clks - load instr 
 1ce:	e0 cf       	rjmp	.-64     	; 0x190 <next_byte>

000001d0 <do_man_bit_high>:

	// 
do_man_bit_high:
	rjmp 1f		// we are here by the first cond, 
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <do_man_bit_high+0x2>
1:	rjmp 2f	// we have to eath 6 clks, before doing anything 
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <do_man_bit_high+0x4>
2: 	rjmp 3f
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <do_man_bit_high+0x6>
3: 
	subi	current_byte, lo8(128)	// 1 clk, similar to xor-ing high bit with 1
 1d6:	40 58       	subi	r20, 0x80	; 128
	dec		tmp_reg2		// 1 clk
 1d8:	2a 95       	dec	r18
	rjmp	next_bit_skip_3clk		// 2 clk
 1da:	df cf       	rjmp	.-66     	; 0x19a <next_bit_skip_3clk>

000001dc <do_man_bit>:

do_man_bit:
	subi	current_byte, lo8(128)	// 1 clk, similar to xor-ing high bit with 1
 1dc:	40 58       	subi	r20, 0x80	; 128
	dec		tmp_reg2		// 1 clk
 1de:	2a 95       	dec	r18

	// for the last bit we should say '0', '0' seq
	cpi 	LOOP_CNT, lo8(1) // 1 clk
 1e0:	01 30       	cpi	r16, 0x01	; 1
	brne	not_last     // 2 clk if branched, 1 if not
 1e2:	09 f4       	brne	.+2      	; 0x1e6 <not_last>
	clr		current_byte		// +1 clk if not branched, so anyway, these 3 instrs takes 3clk
 1e4:	44 27       	eor	r20, r20

000001e6 <not_last>:
not_last:
	rjmp	next_bit_skip_3clk		// 2 clk
 1e6:	d9 cf       	rjmp	.-78     	; 0x19a <next_bit_skip_3clk>

000001e8 <outloop>:

outloop:
	// eat 13 clks here
	ldi		tmp_reg1, lo8(4)
 1e8:	14 e0       	ldi	r17, 0x04	; 4
1:	dec 	tmp_reg1
 1ea:	1a 95       	dec	r17
	brne	1b
 1ec:	f1 f7       	brne	.-4      	; 0x1ea <outloop+0x2>
	nop
 1ee:	00 00       	nop

	sbi		TXD_PORT, TXD_PIN
 1f0:	c0 9a       	sbi	0x18, 0	; 24

	ldi		tmp_reg1, lo8(29)
 1f2:	1d e1       	ldi	r17, 0x1D	; 29
1:	dec 	tmp_reg1
 1f4:	1a 95       	dec	r17
	brne	1b
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <outloop+0xc>

	sbis	RXD_PORT, RXD_PIN	// skip if no ack, 1 clk if ack, 2 clk if no
 1f8:	87 9b       	sbis	0x10, 7	; 16
	rjmp 	has_ack1			// jump ack, 2 clk if ack, 0 if no ack 
 1fa:	01 c0       	rjmp	.+2      	; 0x1fe <has_ack1>
	ori		result, lo8(128)	// 1 clk if no ack
 1fc:	50 68       	ori	r21, 0x80	; 128

000001fe <has_ack1>:
has_ack1:

	ldi 	tmp_reg1, lo8(41)
 1fe:	19 e2       	ldi	r17, 0x29	; 41
1:	dec 	tmp_reg1
 200:	1a 95       	dec	r17
	brne	1b
 202:	f1 f7       	brne	.-4      	; 0x200 <has_ack1+0x2>
	rjmp 	2f
 204:	00 c0       	rjmp	.+0      	; 0x206 <has_ack1+0x8>
2:

	sbic	RXD_PORT, RXD_PIN	// skip if ack, this is the last sampling, 
 206:	87 99       	sbic	0x10, 7	; 16
							 	// do not worry about timing...
	ori		result, lo8(64)
 208:	50 64       	ori	r21, 0x40	; 64

0000020a <fn_return>:

fn_return:
	mov 	r24,result // result
 20a:	85 2f       	mov	r24, r21

0000020c <fn_return_result>:
fn_return_result:	
	pop		r31
 20c:	ff 91       	pop	r31
	pop		r30
 20e:	ef 91       	pop	r30
	pop 	r21
 210:	5f 91       	pop	r21
	pop 	r20
 212:	4f 91       	pop	r20
	
	pop 	r19
 214:	3f 91       	pop	r19
	pop 	r18
 216:	2f 91       	pop	r18
	pop 	r17
 218:	1f 91       	pop	r17
	pop 	r16
 21a:	0f 91       	pop	r16
	pop		r15
 21c:	ff 90       	pop	r15

	ret
 21e:	08 95       	ret

00000220 <fn_return_fail_2>:

fn_return_fail_2:
	ldi 	r24, lo8(2)
 220:	82 e0       	ldi	r24, 0x02	; 2
	rjmp 	fn_return_result
 222:	f4 cf       	rjmp	.-24     	; 0x20c <fn_return_result>

00000224 <fn_return_fail_1>:

fn_return_fail_1:
	ldi 	r24, lo8(1)
 224:	81 e0       	ldi	r24, 0x01	; 1
	rjmp	fn_return_result
 226:	f2 cf       	rjmp	.-28     	; 0x20c <fn_return_result>

00000228 <orbitary_transmit_0>:
// wait frame_start, as we loose arbitration)
// 70% - 89 clks
// routine, including call and ret takes 95
// sample at 89
orbitary_transmit_0:
	cbi		TXD_PORT, TXD_PIN
 228:	c0 98       	cbi	0x18, 0	; 24
	ldi		tmp_reg1, 21
 22a:	15 e1       	ldi	r17, 0x15	; 21

0000022c <orb_loop0>:
orb_loop0:
	dec		tmp_reg1
 22c:	1a 95       	dec	r17
	cpi		tmp_reg1, 0
 22e:	10 30       	cpi	r17, 0x00	; 0
	brne	orb_loop0	
 230:	e9 f7       	brne	.-6      	; 0x22c <orb_loop0>
	sbic	RXD_PORT, RXD_PIN
 232:	87 99       	sbic	0x10, 7	; 16
	rjmp 	we_have_loose_arbitration	
 234:	09 c0       	rjmp	.+18     	; 0x248 <we_have_loose_arbitration>
 	ret	
 236:	08 95       	ret

00000238 <orbitary_transmit_1>:
// wait frame_start, as we loose arbitration)
// 70% - 89 clks
// routine, including call and ret takes 95
// sample at 89
orbitary_transmit_1:
	sbi		TXD_PORT, TXD_PIN
 238:	c0 9a       	sbi	0x18, 0	; 24
	ldi		tmp_reg1, 21
 23a:	15 e1       	ldi	r17, 0x15	; 21

0000023c <orb_loop1>:
orb_loop1:
	dec		tmp_reg1
 23c:	1a 95       	dec	r17
	cpi		tmp_reg1, 0
 23e:	10 30       	cpi	r17, 0x00	; 0
	brne	orb_loop1	
 240:	e9 f7       	brne	.-6      	; 0x23c <orb_loop1>
#ifdef SIMULATOR_DEBUG
	sbic 	RXD_PORT, RXD_PIN // we do not have ext hardware simulated.
#else
	sbis	RXD_PORT, RXD_PIN
 242:	87 9b       	sbis	0x10, 7	; 16
#endif
	rjmp 	we_have_loose_arbitration	
 244:	01 c0       	rjmp	.+2      	; 0x248 <we_have_loose_arbitration>
 	ret				
 246:	08 95       	ret

00000248 <we_have_loose_arbitration>:

we_have_loose_arbitration:
	pop 	tmp_reg1	// remove return address from the stack
 248:	1f 91       	pop	r17
	pop		tmp_reg1	// which is 2 bytes long 
 24a:	1f 91       	pop	r17
	rjmp	to_next_line_idle
 24c:	98 cf       	rjmp	.-208    	; 0x17e <to_next_line_idle>

0000024e <delayms>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 24e:	20 ea       	ldi	r18, 0xA0	; 160
 250:	3f e0       	ldi	r19, 0x0F	; 15
 252:	04 c0       	rjmp	.+8      	; 0x25c <delayms+0xe>
 254:	f9 01       	movw	r30, r18
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	f1 f7       	brne	.-4      	; 0x256 <delayms+0x8>

void delayms(uint16_t millis) 
{
	while ( millis ) {
		_delay_ms(1);
		millis--;
 25a:	01 97       	sbiw	r24, 0x01	; 1
#define RX_BUFFER_SIZE 256*3 


void delayms(uint16_t millis) 
{
	while ( millis ) {
 25c:	00 97       	sbiw	r24, 0x00	; 0
 25e:	d1 f7       	brne	.-12     	; 0x254 <delayms+0x6>
		_delay_ms(1);
		millis--;
	}
}
 260:	08 95       	ret

00000262 <USART_vInit>:


void USART_vInit(void)
{
	// Set frame format to 8 data bits, no parity, 1 stop bit
	UCSRC = (uint8_t)((1<<URSEL) | (0<<USBS)|(1<<UCSZ1)|(1<<UCSZ0));
 262:	86 e8       	ldi	r24, 0x86	; 134
 264:	80 bd       	out	0x20, r24	; 32
#ifdef DEVICE_REV_2
	UCSRA  |= (1<<U2X);
	INIT_ACK();
#endif
	// Set baud rate
	UBRRH = (uint8_t)(USART_UBBR_VALUE>>8);
 266:	10 bc       	out	0x20, r1	; 32
	UBRRL = (uint8_t)USART_UBBR_VALUE;
 268:	88 e0       	ldi	r24, 0x08	; 8
 26a:	89 b9       	out	0x09, r24	; 9

	// Enable receiver and transmitter
	UCSRB = (uint8_t)((1<<RXEN)|(1<<TXEN));
 26c:	88 e1       	ldi	r24, 0x18	; 24
 26e:	8a b9       	out	0x0a, r24	; 10
}
 270:	08 95       	ret

00000272 <USART_vSendByte>:

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 272:	5d 9b       	sbis	0x0b, 5	; 11
 274:	fe cf       	rjmp	.-4      	; 0x272 <USART_vSendByte>
	// Transmit data
	UDR = u8Data;
 276:	8c b9       	out	0x0c, r24	; 12
}
 278:	08 95       	ret

0000027a <USART_vReceiveByte>:

uint8_t USART_vReceiveByte()
{
	uint8_t r;
	// Wait until a byte has been received
	while((UCSRA&(1<<RXC)) == 0) ;
 27a:	5f 9b       	sbis	0x0b, 7	; 11
 27c:	fe cf       	rjmp	.-4      	; 0x27a <USART_vReceiveByte>
	// Return received data
	r = UDR;
 27e:	8c b1       	in	r24, 0x0c	; 12
	SEND_ACK(); // aknowledge receiving
	return r;
}
 280:	08 95       	ret

00000282 <USART_sendCrLf>:

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 282:	5d 9b       	sbis	0x0b, 5	; 11
 284:	fe cf       	rjmp	.-4      	; 0x282 <USART_sendCrLf>
	// Transmit data
	UDR = u8Data;
 286:	8d e0       	ldi	r24, 0x0D	; 13
 288:	8c b9       	out	0x0c, r24	; 12

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 28a:	5d 9b       	sbis	0x0b, 5	; 11
 28c:	fe cf       	rjmp	.-4      	; 0x28a <USART_sendCrLf+0x8>
	// Transmit data
	UDR = u8Data;
 28e:	8a e0       	ldi	r24, 0x0A	; 10
 290:	8c b9       	out	0x0c, r24	; 12

void USART_sendCrLf()
{
	USART_vSendByte('\r');
	USART_vSendByte('\n');
}
 292:	08 95       	ret

00000294 <USART_hasByte>:


uint8_t USART_hasByte()
{
	return (UCSRA&(1<<RXC)) != 0;
 294:	8b b1       	in	r24, 0x0b	; 11
}
 296:	88 1f       	adc	r24, r24
 298:	88 27       	eor	r24, r24
 29a:	88 1f       	adc	r24, r24
 29c:	08 95       	ret

0000029e <crc_init>:
		}


void crc_init()
{
	crc_h = 0xff;
 29e:	55 24       	eor	r5, r5
 2a0:	5a 94       	dec	r5
	crc_l = 0xfe;
 2a2:	8e ef       	ldi	r24, 0xFE	; 254
 2a4:	48 2e       	mov	r4, r24
}
 2a6:	08 95       	ret

000002a8 <crc_fin>:
void crc_fin()
{
	crc_h ^= 0xff;
 2a8:	50 94       	com	r5
	crc_l ^= 0xfe; // lower bit will be always zero due to <<=1
 2aa:	8e ef       	ldi	r24, 0xFE	; 254
 2ac:	48 26       	eor	r4, r24
}
 2ae:	08 95       	ret

000002b0 <fill_packet_crc>:

void fill_packet_crc(const uint8_t *pkt, uint8_t len, uint8_t *crc_place) 
{
 2b0:	fc 01       	movw	r30, r24
 2b2:	da 01       	movw	r26, r20
		}


void crc_init()
{
	crc_h = 0xff;
 2b4:	55 24       	eor	r5, r5
 2b6:	5a 94       	dec	r5
	crc_l = 0xfe;
 2b8:	9e ef       	ldi	r25, 0xFE	; 254
 2ba:	49 2e       	mov	r4, r25
	while (len--) {
		uint8_t c = *pkt; ++pkt;
		while (c) {
			if (c & 0x80)
				crc_add_1();
			crc_proceed_bit();
 2bc:	4f e0       	ldi	r20, 0x0F	; 15
 2be:	3d e9       	ldi	r19, 0x9D	; 157
 2c0:	14 c0       	rjmp	.+40     	; 0x2ea <fill_packet_crc+0x3a>
void fill_packet_crc(const uint8_t *pkt, uint8_t len, uint8_t *crc_place) 
{
	crc_init();
	
	while (len--) {
		uint8_t c = *pkt; ++pkt;
 2c2:	90 81       	ld	r25, Z
 2c4:	24 2d       	mov	r18, r4
 2c6:	85 2d       	mov	r24, r5
 2c8:	0a c0       	rjmp	.+20     	; 0x2de <fill_packet_crc+0x2e>
		while (c) {
			if (c & 0x80)
 2ca:	97 fd       	sbrc	r25, 7
				crc_add_1();
 2cc:	80 58       	subi	r24, 0x80	; 128
			crc_proceed_bit();
 2ce:	87 ff       	sbrs	r24, 7
 2d0:	02 c0       	rjmp	.+4      	; 0x2d6 <fill_packet_crc+0x26>
 2d2:	84 27       	eor	r24, r20
 2d4:	23 27       	eor	r18, r19
 2d6:	88 94       	clc
 2d8:	44 1c       	adc	r4, r4
 2da:	55 1c       	adc	r5, r5
			c <<= 1;
 2dc:	99 0f       	add	r25, r25
{
	crc_init();
	
	while (len--) {
		uint8_t c = *pkt; ++pkt;
		while (c) {
 2de:	99 23       	and	r25, r25
 2e0:	a1 f7       	brne	.-24     	; 0x2ca <fill_packet_crc+0x1a>
 2e2:	42 2e       	mov	r4, r18
 2e4:	58 2e       	mov	r5, r24
void fill_packet_crc(const uint8_t *pkt, uint8_t len, uint8_t *crc_place) 
{
	crc_init();
	
	while (len--) {
		uint8_t c = *pkt; ++pkt;
 2e6:	31 96       	adiw	r30, 0x01	; 1
 2e8:	61 50       	subi	r22, 0x01	; 1

void fill_packet_crc(const uint8_t *pkt, uint8_t len, uint8_t *crc_place) 
{
	crc_init();
	
	while (len--) {
 2ea:	66 23       	and	r22, r22
 2ec:	51 f7       	brne	.-44     	; 0x2c2 <fill_packet_crc+0x12>
	crc_h = 0xff;
	crc_l = 0xfe;
}
void crc_fin()
{
	crc_h ^= 0xff;
 2ee:	95 2d       	mov	r25, r5
 2f0:	90 95       	com	r25
 2f2:	59 2e       	mov	r5, r25
	crc_l ^= 0xfe; // lower bit will be always zero due to <<=1
 2f4:	8e ef       	ldi	r24, 0xFE	; 254
 2f6:	48 26       	eor	r4, r24
			c <<= 1;
		}
	}

	crc_fin();
	crc_place[0] = crc_h;
 2f8:	9c 93       	st	X, r25
	crc_place[1] = crc_l;
 2fa:	11 96       	adiw	r26, 0x01	; 1
 2fc:	4c 92       	st	X, r4
}
 2fe:	08 95       	ret

00000300 <init_timer0>:


void init_timer0() 
{
	// set timer init value
	TCNT0 = 0;
 300:	12 be       	out	0x32, r1	; 50
	// init with /8 prescale
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
 302:	82 e0       	ldi	r24, 0x02	; 2
 304:	83 bf       	out	0x33, r24	; 51
}
 306:	08 95       	ret

00000308 <init_timer1>:
}

void init_timer1() 
{
	// set timer init value
	TCNT1 = 0;
 308:	1d bc       	out	0x2d, r1	; 45
 30a:	1c bc       	out	0x2c, r1	; 44
	// init without prescale
//	TCCR1A = 0;
	TCCR1B = (0<<CS12) | (0<<CS11) | (1<<CS10); 
 30c:	81 e0       	ldi	r24, 0x01	; 1
 30e:	8e bd       	out	0x2e, r24	; 46
}
 310:	08 95       	ret

00000312 <init_VAN_pins>:


void init_VAN_pins()
{
	// PB0 is connected to TxD, so output
	DDRB = (uint8_t)( (1 << DDB0)); // set to output
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	87 bb       	out	0x17, r24	; 23
	
	// PD7 is connected to RxD, so input
	DDRD = (uint8_t)(0 << DDD7);
 316:	11 ba       	out	0x11, r1	; 17

}
 318:	08 95       	ret

0000031a <pullup_unsed_pins>:

	// PC0-PC5 are used for leds in rev1, 
	// PC0/PC1 are leds in rev2, PC2 is WAIT_ACK, PC3/PC4 are JPs in rev2
	// PC6 is reset
	// 
	PORTC = 0;
 31a:	15 ba       	out	0x15, r1	; 21

	// PD7 is RxD VAN
	// PD0-PD1 - USART
	// unused: PD2,PD3,PD4,PD5,PD6
	PORTD = (1<<PD2) | (1<<PD3) | (1<<PD4) | (1<<PD5) | (1<<PD6);
 31c:	8c e7       	ldi	r24, 0x7C	; 124
 31e:	82 bb       	out	0x12, r24	; 18
	// PB0 is TxD VAN
	// PB6,PB7 is XLAT1/XLAT2
	// unused normally (some of ports are connected to programmer):
	// PB5, PB4, PB3, PB2, PB1
	//
	PORTB = (1<<PB1) | (1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5);
 320:	8e e3       	ldi	r24, 0x3E	; 62
 322:	88 bb       	out	0x18, r24	; 24
}
 324:	08 95       	ret

00000326 <show_string>:
//


void show_string (uint8_t id1, uint8_t id2, uint8_t id3)
{
	if (!id1) return;
 326:	88 23       	and	r24, r24
 328:	69 f0       	breq	.+26     	; 0x344 <show_string+0x1e>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 32a:	5d 9b       	sbis	0x0b, 5	; 11
 32c:	fe cf       	rjmp	.-4      	; 0x32a <show_string+0x4>
	// Transmit data
	UDR = u8Data;
 32e:	8c b9       	out	0x0c, r24	; 12

void show_string (uint8_t id1, uint8_t id2, uint8_t id3)
{
	if (!id1) return;
	USART_vSendByte(id1);
	if (!id2) return;
 330:	66 23       	and	r22, r22
 332:	41 f0       	breq	.+16     	; 0x344 <show_string+0x1e>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 334:	5d 9b       	sbis	0x0b, 5	; 11
 336:	fe cf       	rjmp	.-4      	; 0x334 <show_string+0xe>
	// Transmit data
	UDR = u8Data;
 338:	6c b9       	out	0x0c, r22	; 12
{
	if (!id1) return;
	USART_vSendByte(id1);
	if (!id2) return;
	USART_vSendByte(id2);
	if (!id3) return;
 33a:	44 23       	and	r20, r20
 33c:	19 f0       	breq	.+6      	; 0x344 <show_string+0x1e>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 33e:	5d 9b       	sbis	0x0b, 5	; 11
 340:	fe cf       	rjmp	.-4      	; 0x33e <show_string+0x18>
	// Transmit data
	UDR = u8Data;
 342:	4c b9       	out	0x0c, r20	; 12
 344:	08 95       	ret

00000346 <show_string_crlf>:
	USART_vSendByte(id3);
}

void show_string_crlf (uint8_t id1, uint8_t id2, uint8_t id3)
{
	if (!id1) return;
 346:	88 23       	and	r24, r24
 348:	71 f0       	breq	.+28     	; 0x366 <show_string_crlf+0x20>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 34a:	5d 9b       	sbis	0x0b, 5	; 11
 34c:	fe cf       	rjmp	.-4      	; 0x34a <show_string_crlf+0x4>
	// Transmit data
	UDR = u8Data;
 34e:	8c b9       	out	0x0c, r24	; 12

void show_string_crlf (uint8_t id1, uint8_t id2, uint8_t id3)
{
	if (!id1) return;
	USART_vSendByte(id1);
	if (!id2) return;
 350:	66 23       	and	r22, r22
 352:	49 f0       	breq	.+18     	; 0x366 <show_string_crlf+0x20>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 354:	5d 9b       	sbis	0x0b, 5	; 11
 356:	fe cf       	rjmp	.-4      	; 0x354 <show_string_crlf+0xe>
	// Transmit data
	UDR = u8Data;
 358:	6c b9       	out	0x0c, r22	; 12
{
	if (!id1) return;
	USART_vSendByte(id1);
	if (!id2) return;
	USART_vSendByte(id2);
	if (!id3) return;
 35a:	44 23       	and	r20, r20
 35c:	21 f0       	breq	.+8      	; 0x366 <show_string_crlf+0x20>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 35e:	5d 9b       	sbis	0x0b, 5	; 11
 360:	fe cf       	rjmp	.-4      	; 0x35e <show_string_crlf+0x18>
	// Transmit data
	UDR = u8Data;
 362:	4c b9       	out	0x0c, r20	; 12
	USART_vSendByte(id1);
	if (!id2) return;
	USART_vSendByte(id2);
	if (!id3) return;
	USART_vSendByte(id3);
	USART_sendCrLf();
 364:	8e df       	rcall	.-228    	; 0x282 <USART_sendCrLf>
 366:	08 95       	ret

00000368 <send_menu_opt>:
}

void send_menu_opt(uint8_t n, uint8_t id1, uint8_t id2, uint8_t id3)
{
 368:	ff 92       	push	r15
 36a:	0f 93       	push	r16
 36c:	1f 93       	push	r17
 36e:	16 2f       	mov	r17, r22
 370:	04 2f       	mov	r16, r20
 372:	f2 2e       	mov	r15, r18

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 374:	5d 9b       	sbis	0x0b, 5	; 11
 376:	fe cf       	rjmp	.-4      	; 0x374 <send_menu_opt+0xc>
	// Transmit data
	UDR = u8Data;
 378:	8c b9       	out	0x0c, r24	; 12
}

void send_menu_opt(uint8_t n, uint8_t id1, uint8_t id2, uint8_t id3)
{
	USART_vSendByte(n); 
	show_string(' ', '-', ' ');
 37a:	80 e2       	ldi	r24, 0x20	; 32
 37c:	6d e2       	ldi	r22, 0x2D	; 45
 37e:	40 e2       	ldi	r20, 0x20	; 32
 380:	d2 df       	rcall	.-92     	; 0x326 <show_string>
	show_string(id1, id2, id3);
 382:	81 2f       	mov	r24, r17
 384:	60 2f       	mov	r22, r16
 386:	4f 2d       	mov	r20, r15
 388:	ce df       	rcall	.-100    	; 0x326 <show_string>
	USART_sendCrLf();
 38a:	7b df       	rcall	.-266    	; 0x282 <USART_sendCrLf>
}
 38c:	1f 91       	pop	r17
 38e:	0f 91       	pop	r16
 390:	ff 90       	pop	r15
 392:	08 95       	ret

00000394 <vtoh>:



uint8_t vtoh(uint8_t v) 
{
	v &= 0xf;
 394:	8f 70       	andi	r24, 0x0F	; 15
	if (v < 10)
 396:	8a 30       	cpi	r24, 0x0A	; 10
 398:	10 f4       	brcc	.+4      	; 0x39e <vtoh+0xa>
		return v + '0';
 39a:	80 5d       	subi	r24, 0xD0	; 208
 39c:	08 95       	ret
	return v + 'a'-10;
 39e:	89 5a       	subi	r24, 0xA9	; 169
}
 3a0:	08 95       	ret

000003a2 <show_hex>:



uint8_t vtoh(uint8_t v) 
{
	v &= 0xf;
 3a2:	98 2f       	mov	r25, r24
 3a4:	92 95       	swap	r25
 3a6:	9f 70       	andi	r25, 0x0F	; 15
	if (v < 10)
 3a8:	9a 30       	cpi	r25, 0x0A	; 10
 3aa:	10 f4       	brcc	.+4      	; 0x3b0 <show_hex+0xe>
		return v + '0';
 3ac:	90 5d       	subi	r25, 0xD0	; 208
 3ae:	01 c0       	rjmp	.+2      	; 0x3b2 <show_hex+0x10>
	return v + 'a'-10;
 3b0:	99 5a       	subi	r25, 0xA9	; 169

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 3b2:	5d 9b       	sbis	0x0b, 5	; 11
 3b4:	fe cf       	rjmp	.-4      	; 0x3b2 <show_hex+0x10>
	// Transmit data
	UDR = u8Data;
 3b6:	9c b9       	out	0x0c, r25	; 12
	return v + 'a'-10;
}
void show_hex(uint8_t v)
{
	USART_vSendByte(vtoh(v>>4));
	USART_vSendByte(vtoh(v&0xf));
 3b8:	8f 70       	andi	r24, 0x0F	; 15


uint8_t vtoh(uint8_t v) 
{
	v &= 0xf;
	if (v < 10)
 3ba:	8a 30       	cpi	r24, 0x0A	; 10
 3bc:	10 f4       	brcc	.+4      	; 0x3c2 <show_hex+0x20>
		return v + '0';
 3be:	80 5d       	subi	r24, 0xD0	; 208
 3c0:	01 c0       	rjmp	.+2      	; 0x3c4 <show_hex+0x22>
	return v + 'a'-10;
 3c2:	89 5a       	subi	r24, 0xA9	; 169

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 3c4:	5d 9b       	sbis	0x0b, 5	; 11
 3c6:	fe cf       	rjmp	.-4      	; 0x3c4 <show_hex+0x22>
	// Transmit data
	UDR = u8Data;
 3c8:	8c b9       	out	0x0c, r24	; 12
}
void show_hex(uint8_t v)
{
	USART_vSendByte(vtoh(v>>4));
	USART_vSendByte(vtoh(v&0xf));
}
 3ca:	08 95       	ret

000003cc <send_captured>:


// returns 1 when data is sent completely
void send_captured()
{
 3cc:	1f 93       	push	r17
 3ce:	cf 93       	push	r28
 3d0:	df 93       	push	r29
 3d2:	c0 e6       	ldi	r28, 0x60	; 96
 3d4:	d0 e0       	ldi	r29, 0x00	; 0
 3d6:	0f c0       	rjmp	.+30     	; 0x3f6 <send_captured+0x2a>
	uint8_t *send_ptr = &rxb[0];
	uint8_t ln;

	while (send_ptr != rxb_byte_ptr) {
		ln = *send_ptr; ++send_ptr;
 3d8:	19 91       	ld	r17, Y+
 3da:	0a c0       	rjmp	.+20     	; 0x3f0 <send_captured+0x24>
		while (ln > 0) {
			if (send_ptr == rxb_byte_ptr)
 3dc:	80 91 60 03 	lds	r24, 0x0360
 3e0:	90 91 61 03 	lds	r25, 0x0361
 3e4:	c8 17       	cp	r28, r24
 3e6:	d9 07       	cpc	r29, r25
 3e8:	29 f0       	breq	.+10     	; 0x3f4 <send_captured+0x28>
				break;
			show_hex(*send_ptr);
 3ea:	89 91       	ld	r24, Y+
 3ec:	da df       	rcall	.-76     	; 0x3a2 <show_hex>
			++send_ptr;
			--ln;
 3ee:	11 50       	subi	r17, 0x01	; 1
	uint8_t *send_ptr = &rxb[0];
	uint8_t ln;

	while (send_ptr != rxb_byte_ptr) {
		ln = *send_ptr; ++send_ptr;
		while (ln > 0) {
 3f0:	11 23       	and	r17, r17
 3f2:	a1 f7       	brne	.-24     	; 0x3dc <send_captured+0x10>
				break;
			show_hex(*send_ptr);
			++send_ptr;
			--ln;
		}
		USART_sendCrLf();
 3f4:	46 df       	rcall	.-372    	; 0x282 <USART_sendCrLf>
void send_captured()
{
	uint8_t *send_ptr = &rxb[0];
	uint8_t ln;

	while (send_ptr != rxb_byte_ptr) {
 3f6:	80 91 60 03 	lds	r24, 0x0360
 3fa:	90 91 61 03 	lds	r25, 0x0361
 3fe:	c8 17       	cp	r28, r24
 400:	d9 07       	cpc	r29, r25
 402:	51 f7       	brne	.-44     	; 0x3d8 <send_captured+0xc>
			++send_ptr;
			--ln;
		}
		USART_sendCrLf();
	}
}
 404:	df 91       	pop	r29
 406:	cf 91       	pop	r28
 408:	1f 91       	pop	r17
 40a:	08 95       	ret

0000040c <main>:
			"p - USART performance test (will flood with chars)\r\n"\
			"r - reset device\r\n\r\n"\
			"> "

int main(void) 
{
 40c:	6f 92       	push	r6
 40e:	7f 92       	push	r7
 410:	8f 92       	push	r8
 412:	9f 92       	push	r9
 414:	af 92       	push	r10
 416:	bf 92       	push	r11
 418:	cf 92       	push	r12
 41a:	df 92       	push	r13
 41c:	ef 92       	push	r14
 41e:	ff 92       	push	r15
 420:	0f 93       	push	r16
 422:	1f 93       	push	r17
 424:	cf 93       	push	r28
 426:	df 93       	push	r29


void init_VAN_pins()
{
	// PB0 is connected to TxD, so output
	DDRB = (uint8_t)( (1 << DDB0)); // set to output
 428:	99 24       	eor	r9, r9
 42a:	93 94       	inc	r9
 42c:	88 24       	eor	r8, r8
 42e:	83 94       	inc	r8

//#ifdef SIMULATOR_DEBUG
	rxb[0] = 0x8e; rxb[1] = 0x4c;
	rxb[2] = 0x12; rxb[3] = 0x02;
	rxb[4] = 0xc9; rxb[5] = 0x60;
	tx_packet(rxb, 1);
 430:	f0 e6       	ldi	r31, 0x60	; 96
 432:	cf 2e       	mov	r12, r31
 434:	f0 e0       	ldi	r31, 0x00	; 0
 436:	df 2e       	mov	r13, r31

		if (sample_rxd_value()) { 
			rxb_cur_byte |= (uint8_t)0x80; 
			crc_add_1();
		}
		crc_proceed_bit();
 438:	0f e0       	ldi	r16, 0x0F	; 15
 43a:	ed e9       	ldi	r30, 0x9D	; 157
 43c:	fe 2e       	mov	r15, r30

	rxb_byte_ptr = &rxb[0];
	zero_timer0();
	tmp_reg = get_rxd_value();
	*rxb_byte_ptr = tmp_reg; 
	++rxb_byte_ptr;
 43e:	36 01       	movw	r6, r12
 440:	08 94       	sec
 442:	61 1c       	adc	r6, r1
 444:	71 1c       	adc	r7, r1


void init_timer0() 
{
	// set timer init value
	TCNT0 = 0;
 446:	12 be       	out	0x32, r1	; 50
	// init with /8 prescale
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
 448:	92 e0       	ldi	r25, 0x02	; 2
 44a:	93 bf       	out	0x33, r25	; 51


void init_VAN_pins()
{
	// PB0 is connected to TxD, so output
	DDRB = (uint8_t)( (1 << DDB0)); // set to output
 44c:	87 ba       	out	0x17, r8	; 23
	
	// PD7 is connected to RxD, so input
	DDRD = (uint8_t)(0 << DDD7);
 44e:	11 ba       	out	0x11, r1	; 17
}

inline void led_init()
{
#if defined DEVICE_REV_1
	DDRC |= (1<<PC0) | (1<<PC1) | (1<<PC2) | (1<<PC3) | (1<<PC4) | (1<<PC5);/* set PC0-PC5 to output */
 450:	84 b3       	in	r24, 0x14	; 20
 452:	8f 63       	ori	r24, 0x3F	; 63
 454:	84 bb       	out	0x14, r24	; 20
 */

inline void led_show_num(uint8_t num) 
{
#if defined DEVICE_REV_1
	PORTC = num & 63;
 456:	8f e3       	ldi	r24, 0x3F	; 63
 458:	85 bb       	out	0x15, r24	; 21

	// PC0-PC5 are used for leds in rev1, 
	// PC0/PC1 are leds in rev2, PC2 is WAIT_ACK, PC3/PC4 are JPs in rev2
	// PC6 is reset
	// 
	PORTC = 0;
 45a:	15 ba       	out	0x15, r1	; 21
 45c:	15 ba       	out	0x15, r1	; 21

	// PD7 is RxD VAN
	// PD0-PD1 - USART
	// unused: PD2,PD3,PD4,PD5,PD6
	PORTD = (1<<PD2) | (1<<PD3) | (1<<PD4) | (1<<PD5) | (1<<PD6);
 45e:	8c e7       	ldi	r24, 0x7C	; 124
 460:	82 bb       	out	0x12, r24	; 18
	// PB0 is TxD VAN
	// PB6,PB7 is XLAT1/XLAT2
	// unused normally (some of ports are connected to programmer):
	// PB5, PB4, PB3, PB2, PB1
	//
	PORTB = (1<<PB1) | (1<<PB2) | (1<<PB3) | (1<<PB4) | (1<<PB5);
 462:	8e e3       	ldi	r24, 0x3E	; 62
 464:	88 bb       	out	0x18, r24	; 24


void USART_vInit(void)
{
	// Set frame format to 8 data bits, no parity, 1 stop bit
	UCSRC = (uint8_t)((1<<URSEL) | (0<<USBS)|(1<<UCSZ1)|(1<<UCSZ0));
 466:	86 e8       	ldi	r24, 0x86	; 134
 468:	80 bd       	out	0x20, r24	; 32
#ifdef DEVICE_REV_2
	UCSRA  |= (1<<U2X);
	INIT_ACK();
#endif
	// Set baud rate
	UBRRH = (uint8_t)(USART_UBBR_VALUE>>8);
 46a:	10 bc       	out	0x20, r1	; 32
	UBRRL = (uint8_t)USART_UBBR_VALUE;
 46c:	88 e0       	ldi	r24, 0x08	; 8
 46e:	89 b9       	out	0x09, r24	; 9

	// Enable receiver and transmitter
	UCSRB = (uint8_t)((1<<RXEN)|(1<<TXEN));
 470:	88 e1       	ldi	r24, 0x18	; 24
 472:	8a b9       	out	0x0a, r24	; 10
	led_init();
	pullup_unsed_pins();
	USART_vInit();

//#ifdef SIMULATOR_DEBUG
	rxb[0] = 0x8e; rxb[1] = 0x4c;
 474:	8e e8       	ldi	r24, 0x8E	; 142
 476:	80 93 60 00 	sts	0x0060, r24
 47a:	8c e4       	ldi	r24, 0x4C	; 76
 47c:	80 93 61 00 	sts	0x0061, r24
	rxb[2] = 0x12; rxb[3] = 0x02;
 480:	82 e1       	ldi	r24, 0x12	; 18
 482:	80 93 62 00 	sts	0x0062, r24
 486:	90 93 63 00 	sts	0x0063, r25
	rxb[4] = 0xc9; rxb[5] = 0x60;
 48a:	89 ec       	ldi	r24, 0xC9	; 201
 48c:	80 93 64 00 	sts	0x0064, r24
 490:	80 e6       	ldi	r24, 0x60	; 96
 492:	80 93 65 00 	sts	0x0065, r24
	tx_packet(rxb, 1);
 496:	80 e6       	ldi	r24, 0x60	; 96
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	61 e0       	ldi	r22, 0x01	; 1
 49c:	5c de       	rcall	.-840    	; 0x156 <tx_packet>


reset:
	// wait until user says to dump anything
	
	s_ptr = (uint8_t*)PSTR( PROGRAM_MENU );
 49e:	e6 e2       	ldi	r30, 0x26	; 38
 4a0:	f0 e0       	ldi	r31, 0x00	; 0
		rxb[2] = 0x12; rxb[3] = 0x01;
		rxb[4] = 0xe8; rxb[5] = 0x2e;
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == '4') { // switch to cdc
		rxb[0] = 0x8d; rxb[1] = 0x4c;
 4a2:	7d e8       	ldi	r23, 0x8D	; 141
 4a4:	e7 2e       	mov	r14, r23
 4a6:	6c e4       	ldi	r22, 0x4C	; 76
 4a8:	b6 2e       	mov	r11, r22
		rxb[2] = 0x12; rxb[3] = 0x03;
 4aa:	52 e1       	ldi	r21, 0x12	; 18
 4ac:	a5 2e       	mov	r10, r21
 4ae:	07 c0       	rjmp	.+14     	; 0x4be <__stack+0x5f>

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 4b0:	5d 9b       	sbis	0x0b, 5	; 11
 4b2:	fe cf       	rjmp	.-4      	; 0x4b0 <__stack+0x51>

reset:
	// wait until user says to dump anything
	
	s_ptr = (uint8_t*)PSTR( PROGRAM_MENU );
	while( (i=pgm_read_byte(s_ptr++))!=0 ) {
 4b4:	31 96       	adiw	r30, 0x01	; 1
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 4b6:	8c b9       	out	0x0c, r24	; 12
 4b8:	02 c0       	rjmp	.+4      	; 0x4be <__stack+0x5f>


reset:
	// wait until user says to dump anything
	
	s_ptr = (uint8_t*)PSTR( PROGRAM_MENU );
 4ba:	e6 e2       	ldi	r30, 0x26	; 38
 4bc:	f0 e0       	ldi	r31, 0x00	; 0
	while( (i=pgm_read_byte(s_ptr++))!=0 ) {
 4be:	84 91       	lpm	r24, Z+
 4c0:	88 23       	and	r24, r24
 4c2:	b1 f7       	brne	.-20     	; 0x4b0 <__stack+0x51>

uint8_t USART_vReceiveByte()
{
	uint8_t r;
	// Wait until a byte has been received
	while((UCSRA&(1<<RXC)) == 0) ;
 4c4:	5f 9b       	sbis	0x0b, 7	; 11
 4c6:	fe cf       	rjmp	.-4      	; 0x4c4 <__stack+0x65>
	// Return received data
	r = UDR;
 4c8:	1c b1       	in	r17, 0x0c	; 12

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 4ca:	5d 9b       	sbis	0x0b, 5	; 11
 4cc:	fe cf       	rjmp	.-4      	; 0x4ca <__stack+0x6b>
	// Transmit data
	UDR = u8Data;
 4ce:	1c b9       	out	0x0c, r17	; 12
	
	s_ptr = (uint8_t*)PSTR( PROGRAM_MENU );
	while( (i=pgm_read_byte(s_ptr++))!=0 ) {
	    	USART_vSendByte(i); 
	}
	i = USART_vReceiveByte(); USART_vSendByte(i); USART_sendCrLf();
 4d0:	d8 de       	rcall	.-592    	; 0x282 <USART_sendCrLf>

	if (i == 'd') {
 4d2:	14 36       	cpi	r17, 0x64	; 100
 4d4:	09 f4       	brne	.+2      	; 0x4d8 <__stack+0x79>
 4d6:	7f c0       	rjmp	.+254    	; 0x5d6 <__stack+0x177>
		goto init_rx;
	} else if (i == 'm') {
 4d8:	1d 36       	cpi	r17, 0x6D	; 109
 4da:	09 f4       	brne	.+2      	; 0x4de <__stack+0x7f>
 4dc:	db c2       	rjmp	.+1462   	; 0xa94 <__stack+0x635>
		goto monitor_bus;
	} else if (i == '2') { // switch to internal cd
 4de:	12 33       	cpi	r17, 0x32	; 50
 4e0:	71 f4       	brne	.+28     	; 0x4fe <__stack+0x9f>
		rxb[0] = 0x8d; rxb[1] = 0x4c;
 4e2:	e0 92 60 00 	sts	0x0060, r14
 4e6:	b0 92 61 00 	sts	0x0061, r11
		rxb[2] = 0x12; rxb[3] = 0x02;
 4ea:	a0 92 62 00 	sts	0x0062, r10
 4ee:	82 e0       	ldi	r24, 0x02	; 2
 4f0:	80 93 63 00 	sts	0x0063, r24
		rxb[4] = 0xc9; rxb[5] = 0x60;
 4f4:	89 ec       	ldi	r24, 0xC9	; 201
 4f6:	80 93 64 00 	sts	0x0064, r24
 4fa:	80 e6       	ldi	r24, 0x60	; 96
 4fc:	1f c0       	rjmp	.+62     	; 0x53c <__stack+0xdd>
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');		
	} else if (i == '3') { // switch to radio
 4fe:	13 33       	cpi	r17, 0x33	; 51
 500:	71 f4       	brne	.+28     	; 0x51e <__stack+0xbf>
		rxb[0] = 0x8d; rxb[1] = 0x4c;
 502:	e0 92 60 00 	sts	0x0060, r14
 506:	b0 92 61 00 	sts	0x0061, r11
		rxb[2] = 0x12; rxb[3] = 0x01;
 50a:	a0 92 62 00 	sts	0x0062, r10
 50e:	21 e0       	ldi	r18, 0x01	; 1
 510:	20 93 63 00 	sts	0x0063, r18
		rxb[4] = 0xe8; rxb[5] = 0x2e;
 514:	88 ee       	ldi	r24, 0xE8	; 232
 516:	80 93 64 00 	sts	0x0064, r24
 51a:	8e e2       	ldi	r24, 0x2E	; 46
 51c:	0f c0       	rjmp	.+30     	; 0x53c <__stack+0xdd>
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == '4') { // switch to cdc
 51e:	14 33       	cpi	r17, 0x34	; 52
 520:	41 f5       	brne	.+80     	; 0x572 <__stack+0x113>
		rxb[0] = 0x8d; rxb[1] = 0x4c;
 522:	e0 92 60 00 	sts	0x0060, r14
 526:	b0 92 61 00 	sts	0x0061, r11
		rxb[2] = 0x12; rxb[3] = 0x03;
 52a:	a0 92 62 00 	sts	0x0062, r10
 52e:	83 e0       	ldi	r24, 0x03	; 3
 530:	80 93 63 00 	sts	0x0063, r24
		rxb[4] = 0xd6; rxb[5] = 0x5a;
 534:	86 ed       	ldi	r24, 0xD6	; 214
 536:	80 93 64 00 	sts	0x0064, r24
 53a:	8a e5       	ldi	r24, 0x5A	; 90
 53c:	80 93 65 00 	sts	0x0065, r24
		i = tx_packet(rxb, 6);
 540:	80 e6       	ldi	r24, 0x60	; 96
 542:	90 e0       	ldi	r25, 0x00	; 0
 544:	66 e0       	ldi	r22, 0x06	; 6
 546:	07 de       	rcall	.-1010   	; 0x156 <tx_packet>
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
 548:	87 fd       	sbrc	r24, 7
 54a:	02 c0       	rjmp	.+4      	; 0x550 <__stack+0xf1>
 54c:	21 e4       	ldi	r18, 0x41	; 65
 54e:	01 c0       	rjmp	.+2      	; 0x552 <__stack+0xf3>
 550:	2d e2       	ldi	r18, 0x2D	; 45
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	86 fd       	sbrc	r24, 6
 556:	02 c0       	rjmp	.+4      	; 0x55c <__stack+0xfd>
 558:	61 e4       	ldi	r22, 0x41	; 65
 55a:	01 c0       	rjmp	.+2      	; 0x55e <__stack+0xff>
 55c:	6d e2       	ldi	r22, 0x2D	; 45
 55e:	8f 70       	andi	r24, 0x0F	; 15
 560:	90 70       	andi	r25, 0x00	; 0
 562:	89 2b       	or	r24, r25
 564:	11 f4       	brne	.+4      	; 0x56a <__stack+0x10b>
 566:	43 e5       	ldi	r20, 0x53	; 83
 568:	01 c0       	rjmp	.+2      	; 0x56c <__stack+0x10d>
 56a:	45 e4       	ldi	r20, 0x45	; 69
 56c:	82 2f       	mov	r24, r18
 56e:	eb de       	rcall	.-554    	; 0x346 <show_string_crlf>
 570:	a4 cf       	rjmp	.-184    	; 0x4ba <__stack+0x5b>
	} else if (i == 'p') {
 572:	10 37       	cpi	r17, 0x70	; 112
 574:	61 f5       	brne	.+88     	; 0x5ce <__stack+0x16f>
 576:	10 e0       	ldi	r17, 0x00	; 0

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 578:	5d 9b       	sbis	0x0b, 5	; 11
 57a:	fe cf       	rjmp	.-4      	; 0x578 <__stack+0x119>
		rxb[4] = 0xd6; rxb[5] = 0x5a;
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
 57c:	1f 59       	subi	r17, 0x9F	; 159
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 57e:	1c b9       	out	0x0c, r17	; 12
 580:	11 56       	subi	r17, 0x61	; 97

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 582:	5d 9b       	sbis	0x0b, 5	; 11
 584:	fe cf       	rjmp	.-4      	; 0x582 <__stack+0x123>
		rxb[4] = 0xd6; rxb[5] = 0x5a;
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
 586:	1e 59       	subi	r17, 0x9E	; 158
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 588:	1c b9       	out	0x0c, r17	; 12
 58a:	12 56       	subi	r17, 0x62	; 98

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 58c:	5d 9b       	sbis	0x0b, 5	; 11
 58e:	fe cf       	rjmp	.-4      	; 0x58c <__stack+0x12d>
		rxb[4] = 0xd6; rxb[5] = 0x5a;
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
 590:	1d 59       	subi	r17, 0x9D	; 157
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 592:	1c b9       	out	0x0c, r17	; 12
 594:	13 56       	subi	r17, 0x63	; 99

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 596:	5d 9b       	sbis	0x0b, 5	; 11
 598:	fe cf       	rjmp	.-4      	; 0x596 <__stack+0x137>
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
 59a:	1c 59       	subi	r17, 0x9C	; 156
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 59c:	1c b9       	out	0x0c, r17	; 12
 59e:	14 56       	subi	r17, 0x64	; 100

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 5a0:	5d 9b       	sbis	0x0b, 5	; 11
 5a2:	fe cf       	rjmp	.-4      	; 0x5a0 <__stack+0x141>
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
 5a4:	1b 59       	subi	r17, 0x9B	; 155
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 5a6:	1c b9       	out	0x0c, r17	; 12
 5a8:	15 56       	subi	r17, 0x65	; 101

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 5aa:	5d 9b       	sbis	0x0b, 5	; 11
 5ac:	fe cf       	rjmp	.-4      	; 0x5aa <__stack+0x14b>
		i = tx_packet(rxb, 6);
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
 5ae:	1a 59       	subi	r17, 0x9A	; 154
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 5b0:	1c b9       	out	0x0c, r17	; 12
 5b2:	16 56       	subi	r17, 0x66	; 102

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 5b4:	5d 9b       	sbis	0x0b, 5	; 11
 5b6:	fe cf       	rjmp	.-4      	; 0x5b4 <__stack+0x155>
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
			USART_vSendByte('g'+i); USART_vSendByte('h'+i);
 5b8:	19 59       	subi	r17, 0x99	; 153
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 5ba:	1c b9       	out	0x0c, r17	; 12
 5bc:	17 56       	subi	r17, 0x67	; 103

void USART_vSendByte(uint8_t u8Data)
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
 5be:	5d 9b       	sbis	0x0b, 5	; 11
 5c0:	fe cf       	rjmp	.-4      	; 0x5be <__stack+0x15f>
		show_string_crlf((i & 0x80) ? '-' : 'A', (i & 0x40) ? '-' : 'A', (i & 0x0f) ? 'E' : 'S');
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
			USART_vSendByte('g'+i); USART_vSendByte('h'+i);
 5c2:	18 59       	subi	r17, 0x98	; 152
{
	// Wait if a byte is being transmitted
	WAIT_ACK(); // wait for last byte to be transmitted
	while((UCSRA&(1<<UDRE)) == 0);
	// Transmit data
	UDR = u8Data;
 5c4:	1c b9       	out	0x0c, r17	; 12
	} else if (i == 'p') {
		for (i=0;; ) {
			USART_vSendByte('a'+i); USART_vSendByte('b'+i); USART_vSendByte('c'+i); 
			USART_vSendByte('d'+i); USART_vSendByte('e'+i); USART_vSendByte('f'+i);
			USART_vSendByte('g'+i); USART_vSendByte('h'+i);
			USART_sendCrLf(); 
 5c6:	5d de       	rcall	.-838    	; 0x282 <USART_sendCrLf>
			++i;
 5c8:	17 56       	subi	r17, 0x67	; 103
			i &= 0xf;
 5ca:	1f 70       	andi	r17, 0x0F	; 15
 5cc:	d5 cf       	rjmp	.-86     	; 0x578 <__stack+0x119>
		}
	} else if (i == 'r') {
 5ce:	12 37       	cpi	r17, 0x72	; 114
 5d0:	09 f4       	brne	.+2      	; 0x5d4 <__stack+0x175>
 5d2:	39 cf       	rjmp	.-398    	; 0x446 <main+0x3a>
 5d4:	72 cf       	rjmp	.-284    	; 0x4ba <__stack+0x5b>


inline void set_txd_value(uint8_t v)
{
	if (v)
		PORTB |= (uint8_t)(1<<PB0);
 5d6:	c0 9a       	sbi	0x18, 0	; 24
	TCNT0 = value;
}

inline void zero_timer0()
{
	TCNT0 = (uint8_t) 0;
 5d8:	12 be       	out	0x32, r1	; 50
init_rx:
	set_txd_value(1);
	zero_timer0();

	// fill buffer until filled
	rxb_byte_ptr = &rxb[0];
 5da:	d0 92 61 03 	sts	0x0361, r13
 5de:	c0 92 60 03 	sts	0x0360, r12
 5e2:	94 2d       	mov	r25, r4
 5e4:	25 2d       	mov	r18, r5
 5e6:	43 2d       	mov	r20, r3
 5e8:	02 c0       	rjmp	.+4      	; 0x5ee <__stack+0x18f>
 5ea:	2f ef       	ldi	r18, 0xFF	; 255
 5ec:	9e ef       	ldi	r25, 0xFE	; 254
uint8_t tx_packet(const uint8_t *pkt, uint8_t len);


inline uint8_t check_reset() 
{
	return (USART_hasByte() && USART_vReceiveByte() == 'r');
 5ee:	5f 9b       	sbis	0x0b, 7	; 11
 5f0:	0e c0       	rjmp	.+28     	; 0x60e <__stack+0x1af>

uint8_t USART_vReceiveByte()
{
	uint8_t r;
	// Wait until a byte has been received
	while((UCSRA&(1<<RXC)) == 0) ;
 5f2:	5f 9b       	sbis	0x0b, 7	; 11
 5f4:	fe cf       	rjmp	.-4      	; 0x5f2 <__stack+0x193>
	// Return received data
	r = UDR;
 5f6:	8c b1       	in	r24, 0x0c	; 12
 5f8:	30 e0       	ldi	r19, 0x00	; 0
 5fa:	82 37       	cpi	r24, 0x72	; 114
 5fc:	09 f0       	breq	.+2      	; 0x600 <__stack+0x1a1>
 5fe:	31 e0       	ldi	r19, 0x01	; 1
	// busy line is 1, peamble is starting from zero.
	// so actually wait for preamble
	//
wait_frame_start: 
	// check for 'r' pressed
	if (check_reset()) {
 600:	39 15       	cp	r19, r9
 602:	29 f0       	breq	.+10     	; 0x60e <__stack+0x1af>
 604:	49 2e       	mov	r4, r25
 606:	52 2e       	mov	r5, r18
 608:	34 2e       	mov	r3, r20
		send_captured();
 60a:	e0 de       	rcall	.-576    	; 0x3cc <send_captured>
 60c:	56 cf       	rjmp	.-340    	; 0x4ba <__stack+0x5b>
	TCNT0 = value;
}

inline void zero_timer0()
{
	TCNT0 = (uint8_t) 0;
 60e:	12 be       	out	0x32, r1	; 50
 610:	80 e0       	ldi	r24, 0x00	; 0
 612:	03 c0       	rjmp	.+6      	; 0x61a <__stack+0x1bb>
	i = 0;
	zero_timer0();
	crc_init();

	while (get_rxd_value() != 0) { 
		if (i != 255) // check for overflow
 614:	8f 3f       	cpi	r24, 0xFF	; 255
 616:	09 f0       	breq	.+2      	; 0x61a <__stack+0x1bb>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 618:	82 b7       	in	r24, 0x32	; 50
	// noice or part of prev msg, ignoring...
	i = 0;
	zero_timer0();
	crc_init();

	while (get_rxd_value() != 0) { 
 61a:	87 99       	sbic	0x10, 7	; 16
 61c:	fb cf       	rjmp	.-10     	; 0x614 <__stack+0x1b5>
	TCNT0 = value;
}

inline void zero_timer0()
{
	TCNT0 = (uint8_t) 0;
 61e:	12 be       	out	0x32, r1	; 50
 620:	2f ef       	ldi	r18, 0xFF	; 255
 622:	9e ef       	ldi	r25, 0xFE	; 254

	// here we got if we got non-zero, reset timer first of all, and only after tmr reset -- 
	// check, how long line was in '1' state
	zero_timer0();

	if (i < 6) 
 624:	86 30       	cpi	r24, 0x06	; 6
 626:	18 f3       	brcs	.-58     	; 0x5ee <__stack+0x18f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 628:	82 b7       	in	r24, 0x32	; 50
	// receive 10-bit with preamble
	// preable is a fixed format: 0000111101
	//
	
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
 62a:	8f 70       	andi	r24, 0x0F	; 15
 62c:	89 30       	cpi	r24, 0x09	; 9
 62e:	e1 f7       	brne	.-8      	; 0x628 <__stack+0x1c9>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 630:	82 b7       	in	r24, 0x32	; 50
	// receive 10-bit with preamble
	// preable is a fixed format: 0000111101
	//
	
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
 632:	8f 70       	andi	r24, 0x0F	; 15
 634:	8a 30       	cpi	r24, 0x0A	; 10
 636:	e1 f7       	brne	.-8      	; 0x630 <__stack+0x1d1>
 638:	2f ef       	ldi	r18, 0xFF	; 255
 63a:	9e ef       	ldi	r25, 0xFE	; 254
 63c:	87 99       	sbic	0x10, 7	; 16
 63e:	d7 cf       	rjmp	.-82     	; 0x5ee <__stack+0x18f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 640:	82 b7       	in	r24, 0x32	; 50
	//
	
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 642:	8f 70       	andi	r24, 0x0F	; 15
 644:	89 30       	cpi	r24, 0x09	; 9
 646:	e1 f7       	brne	.-8      	; 0x640 <__stack+0x1e1>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 648:	82 b7       	in	r24, 0x32	; 50
	//
	
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 64a:	8f 70       	andi	r24, 0x0F	; 15
 64c:	8a 30       	cpi	r24, 0x0A	; 10
 64e:	e1 f7       	brne	.-8      	; 0x648 <__stack+0x1e9>
 650:	2f ef       	ldi	r18, 0xFF	; 255
 652:	9e ef       	ldi	r25, 0xFE	; 254
 654:	87 99       	sbic	0x10, 7	; 16
 656:	cb cf       	rjmp	.-106    	; 0x5ee <__stack+0x18f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 658:	82 b7       	in	r24, 0x32	; 50
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 65a:	8f 70       	andi	r24, 0x0F	; 15
 65c:	89 30       	cpi	r24, 0x09	; 9
 65e:	e1 f7       	brne	.-8      	; 0x658 <__stack+0x1f9>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 660:	82 b7       	in	r24, 0x32	; 50
	// check first 4 bits to be all zeros
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 662:	8f 70       	andi	r24, 0x0F	; 15
 664:	8a 30       	cpi	r24, 0x0A	; 10
 666:	e1 f7       	brne	.-8      	; 0x660 <__stack+0x201>
 668:	2f ef       	ldi	r18, 0xFF	; 255
 66a:	9e ef       	ldi	r25, 0xFE	; 254
 66c:	87 99       	sbic	0x10, 7	; 16
 66e:	bf cf       	rjmp	.-130    	; 0x5ee <__stack+0x18f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 670:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 672:	8f 70       	andi	r24, 0x0F	; 15
 674:	89 30       	cpi	r24, 0x09	; 9
 676:	e1 f7       	brne	.-8      	; 0x670 <__stack+0x211>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 678:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
 67a:	8f 70       	andi	r24, 0x0F	; 15
 67c:	8a 30       	cpi	r24, 0x0A	; 10
 67e:	e1 f7       	brne	.-8      	; 0x678 <__stack+0x219>
 680:	2f ef       	ldi	r18, 0xFF	; 255
 682:	9e ef       	ldi	r25, 0xFE	; 254
 684:	87 99       	sbic	0x10, 7	; 16
 686:	b3 cf       	rjmp	.-154    	; 0x5ee <__stack+0x18f>
 688:	06 c0       	rjmp	.+12     	; 0x696 <__stack+0x237>
		goto wait_frame_start;

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
 68a:	87 9b       	sbis	0x10, 7	; 16
 68c:	04 c0       	rjmp	.+8      	; 0x696 <__stack+0x237>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 68e:	42 b7       	in	r20, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
 690:	44 23       	and	r20, r20
 692:	51 f0       	breq	.+20     	; 0x6a8 <__stack+0x249>
 694:	06 c0       	rjmp	.+12     	; 0x6a2 <__stack+0x243>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 696:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
 698:	8f 70       	andi	r24, 0x0F	; 15
 69a:	89 30       	cpi	r24, 0x09	; 9
 69c:	b1 f7       	brne	.-20     	; 0x68a <__stack+0x22b>
 69e:	40 e0       	ldi	r20, 0x00	; 0
 6a0:	03 c0       	rjmp	.+6      	; 0x6a8 <__stack+0x249>
 6a2:	82 b7       	in	r24, 0x32	; 50
 6a4:	84 1b       	sub	r24, r20
 6a6:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6a8:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() != 0) 
		goto wait_frame_start;

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
 6aa:	8f 70       	andi	r24, 0x0F	; 15
 6ac:	8a 30       	cpi	r24, 0x0A	; 10
 6ae:	e1 f7       	brne	.-8      	; 0x6a8 <__stack+0x249>
	if (get_rxd_value() == 0) 
 6b0:	87 9b       	sbis	0x10, 7	; 16
 6b2:	9b cf       	rjmp	.-202    	; 0x5ea <__stack+0x18b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6b4:	82 b7       	in	r24, 0x32	; 50

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
	if (get_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6b6:	8f 70       	andi	r24, 0x0F	; 15
 6b8:	89 30       	cpi	r24, 0x09	; 9
 6ba:	e1 f7       	brne	.-8      	; 0x6b4 <__stack+0x255>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6bc:	82 b7       	in	r24, 0x32	; 50

	// check next 4 bits to be all onces:
	wait_synced_on_rising_edge();
	if (get_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6be:	8f 70       	andi	r24, 0x0F	; 15
 6c0:	8a 30       	cpi	r24, 0x0A	; 10
 6c2:	e1 f7       	brne	.-8      	; 0x6bc <__stack+0x25d>
 6c4:	87 9b       	sbis	0x10, 7	; 16
 6c6:	91 cf       	rjmp	.-222    	; 0x5ea <__stack+0x18b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6c8:	82 b7       	in	r24, 0x32	; 50
	wait_synced_on_rising_edge();
	if (get_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6ca:	8f 70       	andi	r24, 0x0F	; 15
 6cc:	89 30       	cpi	r24, 0x09	; 9
 6ce:	e1 f7       	brne	.-8      	; 0x6c8 <__stack+0x269>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6d0:	82 b7       	in	r24, 0x32	; 50
	wait_synced_on_rising_edge();
	if (get_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6d2:	8f 70       	andi	r24, 0x0F	; 15
 6d4:	8a 30       	cpi	r24, 0x0A	; 10
 6d6:	e1 f7       	brne	.-8      	; 0x6d0 <__stack+0x271>
 6d8:	87 9b       	sbis	0x10, 7	; 16
 6da:	87 cf       	rjmp	.-242    	; 0x5ea <__stack+0x18b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6dc:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6de:	8f 70       	andi	r24, 0x0F	; 15
 6e0:	89 30       	cpi	r24, 0x09	; 9
 6e2:	e1 f7       	brne	.-8      	; 0x6dc <__stack+0x27d>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6e4:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
 6e6:	8f 70       	andi	r24, 0x0F	; 15
 6e8:	8a 30       	cpi	r24, 0x0A	; 10
 6ea:	e1 f7       	brne	.-8      	; 0x6e4 <__stack+0x285>
 6ec:	87 9b       	sbis	0x10, 7	; 16
 6ee:	7d cf       	rjmp	.-262    	; 0x5ea <__stack+0x18b>
 6f0:	06 c0       	rjmp	.+12     	; 0x6fe <__stack+0x29f>
		goto wait_frame_start;

	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
 6f2:	87 99       	sbic	0x10, 7	; 16
 6f4:	04 c0       	rjmp	.+8      	; 0x6fe <__stack+0x29f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6f6:	42 b7       	in	r20, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;

	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
 6f8:	44 23       	and	r20, r20
 6fa:	51 f0       	breq	.+20     	; 0x710 <__stack+0x2b1>
 6fc:	06 c0       	rjmp	.+12     	; 0x70a <__stack+0x2ab>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 6fe:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;

	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
 700:	8f 70       	andi	r24, 0x0F	; 15
 702:	89 30       	cpi	r24, 0x09	; 9
 704:	b1 f7       	brne	.-20     	; 0x6f2 <__stack+0x293>
 706:	40 e0       	ldi	r20, 0x00	; 0
 708:	03 c0       	rjmp	.+6      	; 0x710 <__stack+0x2b1>
 70a:	82 b7       	in	r24, 0x32	; 50
 70c:	84 1b       	sub	r24, r20
 70e:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 710:	82 b7       	in	r24, 0x32	; 50
		goto wait_frame_start;
	if (sample_rxd_value() == 0) 
		goto wait_frame_start;

	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
 712:	8f 70       	andi	r24, 0x0F	; 15
 714:	8a 30       	cpi	r24, 0x0A	; 10
 716:	e1 f7       	brne	.-8      	; 0x710 <__stack+0x2b1>
	if (get_rxd_value() != 0) 
 718:	87 99       	sbic	0x10, 7	; 16
 71a:	67 cf       	rjmp	.-306    	; 0x5ea <__stack+0x18b>
 71c:	06 c0       	rjmp	.+12     	; 0x72a <__stack+0x2cb>
		goto wait_frame_start;
	
	wait_synced_on_rising_edge();
 71e:	87 9b       	sbis	0x10, 7	; 16
 720:	04 c0       	rjmp	.+8      	; 0x72a <__stack+0x2cb>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 722:	42 b7       	in	r20, 0x32	; 50
	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
	if (get_rxd_value() != 0) 
		goto wait_frame_start;
	
	wait_synced_on_rising_edge();
 724:	44 23       	and	r20, r20
 726:	51 f0       	breq	.+20     	; 0x73c <__stack+0x2dd>
 728:	06 c0       	rjmp	.+12     	; 0x736 <__stack+0x2d7>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 72a:	82 b7       	in	r24, 0x32	; 50
	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
	if (get_rxd_value() != 0) 
		goto wait_frame_start;
	
	wait_synced_on_rising_edge();
 72c:	8f 70       	andi	r24, 0x0F	; 15
 72e:	89 30       	cpi	r24, 0x09	; 9
 730:	b1 f7       	brne	.-20     	; 0x71e <__stack+0x2bf>
 732:	40 e0       	ldi	r20, 0x00	; 0
 734:	03 c0       	rjmp	.+6      	; 0x73c <__stack+0x2dd>
 736:	82 b7       	in	r24, 0x32	; 50
 738:	84 1b       	sub	r24, r20
 73a:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 73c:	82 b7       	in	r24, 0x32	; 50
	// check last 2 preamble bits to be 0/1
	wait_synced_on_falling_edge();
	if (get_rxd_value() != 0) 
		goto wait_frame_start;
	
	wait_synced_on_rising_edge();
 73e:	8f 70       	andi	r24, 0x0F	; 15
 740:	8a 30       	cpi	r24, 0x0A	; 10
 742:	e1 f7       	brne	.-8      	; 0x73c <__stack+0x2dd>
	if (get_rxd_value() == 0) 
 744:	87 9b       	sbis	0x10, 7	; 16
 746:	51 cf       	rjmp	.-350    	; 0x5ea <__stack+0x18b>
		goto wait_frame_start;
 748:	4e ef       	ldi	r20, 0xFE	; 254
 74a:	44 2e       	mov	r4, r20
 74c:	55 24       	eor	r5, r5
 74e:	5a 94       	dec	r5
	//
	// So, finally, read up to 2+28+2=32 bytes, untill reaches EOD
	//

	// reserve room for msg length
	s_ptr = rxb_byte_ptr;
 750:	a0 91 60 03 	lds	r26, 0x0360
 754:	b0 91 61 03 	lds	r27, 0x0361
	++rxb_byte_ptr;
 758:	11 96       	adiw	r26, 0x01	; 1
 75a:	b0 93 61 03 	sts	0x0361, r27
 75e:	a0 93 60 03 	sts	0x0360, r26
 762:	11 97       	sbiw	r26, 0x01	; 1
 764:	20 e0       	ldi	r18, 0x00	; 0

	for (i=0; i<32; i++) { // do not allow to overflow buffer
		rxb_cur_byte = 0;
 766:	22 24       	eor	r2, r2
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 768:	82 b7       	in	r24, 0x32	; 50
	for (i=0; i<32; i++) { // do not allow to overflow buffer
		rxb_cur_byte = 0;
		// decode higher 4-bits:
		// get NRZ bits

		if (sample_rxd_value()) { 
 76a:	8f 70       	andi	r24, 0x0F	; 15
 76c:	89 30       	cpi	r24, 0x09	; 9
 76e:	e1 f7       	brne	.-8      	; 0x768 <__stack+0x309>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 770:	82 b7       	in	r24, 0x32	; 50
	for (i=0; i<32; i++) { // do not allow to overflow buffer
		rxb_cur_byte = 0;
		// decode higher 4-bits:
		// get NRZ bits

		if (sample_rxd_value()) { 
 772:	8f 70       	andi	r24, 0x0F	; 15
 774:	8a 30       	cpi	r24, 0x0A	; 10
 776:	e1 f7       	brne	.-8      	; 0x770 <__stack+0x311>
 778:	87 9b       	sbis	0x10, 7	; 16
 77a:	03 c0       	rjmp	.+6      	; 0x782 <__stack+0x323>
			rxb_cur_byte |= (uint8_t)0x80; 
 77c:	30 e8       	ldi	r19, 0x80	; 128
 77e:	23 2e       	mov	r2, r19
			crc_add_1();
 780:	52 0c       	add	r5, r2
		}
		crc_proceed_bit();
 782:	57 fe       	sbrs	r5, 7
 784:	02 c0       	rjmp	.+4      	; 0x78a <__stack+0x32b>
 786:	50 26       	eor	r5, r16
 788:	4f 24       	eor	r4, r15
 78a:	88 94       	clc
 78c:	44 1c       	adc	r4, r4
 78e:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 790:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x80; 
			crc_add_1();
		}
		crc_proceed_bit();

		if (sample_rxd_value()) { 
 792:	8f 70       	andi	r24, 0x0F	; 15
 794:	89 30       	cpi	r24, 0x09	; 9
 796:	e1 f7       	brne	.-8      	; 0x790 <__stack+0x331>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 798:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x80; 
			crc_add_1();
		}
		crc_proceed_bit();

		if (sample_rxd_value()) { 
 79a:	8f 70       	andi	r24, 0x0F	; 15
 79c:	8a 30       	cpi	r24, 0x0A	; 10
 79e:	e1 f7       	brne	.-8      	; 0x798 <__stack+0x339>
 7a0:	87 9b       	sbis	0x10, 7	; 16
 7a2:	04 c0       	rjmp	.+8      	; 0x7ac <__stack+0x34d>
			rxb_cur_byte |= (uint8_t)0x40;
 7a4:	80 e4       	ldi	r24, 0x40	; 64
 7a6:	28 2a       	or	r2, r24
			crc_add_1();
 7a8:	80 e8       	ldi	r24, 0x80	; 128
 7aa:	58 0e       	add	r5, r24
		}
		crc_proceed_bit();
 7ac:	57 fe       	sbrs	r5, 7
 7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <__stack+0x355>
 7b0:	50 26       	eor	r5, r16
 7b2:	4f 24       	eor	r4, r15
 7b4:	88 94       	clc
 7b6:	44 1c       	adc	r4, r4
 7b8:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 7ba:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x40;
			crc_add_1();
		}
		crc_proceed_bit();
			
		if (sample_rxd_value()) {
 7bc:	8f 70       	andi	r24, 0x0F	; 15
 7be:	89 30       	cpi	r24, 0x09	; 9
 7c0:	e1 f7       	brne	.-8      	; 0x7ba <__stack+0x35b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 7c2:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x40;
			crc_add_1();
		}
		crc_proceed_bit();
			
		if (sample_rxd_value()) {
 7c4:	8f 70       	andi	r24, 0x0F	; 15
 7c6:	8a 30       	cpi	r24, 0x0A	; 10
 7c8:	e1 f7       	brne	.-8      	; 0x7c2 <__stack+0x363>
 7ca:	87 9b       	sbis	0x10, 7	; 16
 7cc:	04 c0       	rjmp	.+8      	; 0x7d6 <__stack+0x377>
			rxb_cur_byte |= (uint8_t)0x20;
 7ce:	80 e2       	ldi	r24, 0x20	; 32
 7d0:	28 2a       	or	r2, r24
			crc_add_1();
 7d2:	80 e8       	ldi	r24, 0x80	; 128
 7d4:	58 0e       	add	r5, r24
		}
		crc_proceed_bit();
 7d6:	57 fe       	sbrs	r5, 7
 7d8:	02 c0       	rjmp	.+4      	; 0x7de <__stack+0x37f>
 7da:	50 26       	eor	r5, r16
 7dc:	4f 24       	eor	r4, r15
 7de:	88 94       	clc
 7e0:	44 1c       	adc	r4, r4
 7e2:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 7e4:	82 b7       	in	r24, 0x32	; 50
			crc_add_1();
		}
		crc_proceed_bit();

		// get MAN 1st TS
		if (sample_rxd_value()) {
 7e6:	8f 70       	andi	r24, 0x0F	; 15
 7e8:	89 30       	cpi	r24, 0x09	; 9
 7ea:	e1 f7       	brne	.-8      	; 0x7e4 <__stack+0x385>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 7ec:	82 b7       	in	r24, 0x32	; 50
			crc_add_1();
		}
		crc_proceed_bit();

		// get MAN 1st TS
		if (sample_rxd_value()) {
 7ee:	8f 70       	andi	r24, 0x0F	; 15
 7f0:	8a 30       	cpi	r24, 0x0A	; 10
 7f2:	e1 f7       	brne	.-8      	; 0x7ec <__stack+0x38d>
 7f4:	87 9b       	sbis	0x10, 7	; 16
 7f6:	19 c0       	rjmp	.+50     	; 0x82a <__stack+0x3cb>
			rxb_cur_byte |= (uint8_t)0x10;	
 7f8:	80 e1       	ldi	r24, 0x10	; 16
 7fa:	28 2a       	or	r2, r24
			crc_add_1();
 7fc:	80 e8       	ldi	r24, 0x80	; 128
 7fe:	58 0e       	add	r5, r24
			wait_synced_on_falling_edge();	
 800:	33 24       	eor	r3, r3
 802:	05 c0       	rjmp	.+10     	; 0x80e <__stack+0x3af>
 804:	87 99       	sbic	0x10, 7	; 16
 806:	03 c0       	rjmp	.+6      	; 0x80e <__stack+0x3af>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 808:	82 b7       	in	r24, 0x32	; 50

		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
 80a:	38 2e       	mov	r3, r24
 80c:	04 c0       	rjmp	.+8      	; 0x816 <__stack+0x3b7>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 80e:	82 b7       	in	r24, 0x32	; 50

		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
 810:	8f 70       	andi	r24, 0x0F	; 15
 812:	89 30       	cpi	r24, 0x09	; 9
 814:	b9 f7       	brne	.-18     	; 0x804 <__stack+0x3a5>
 816:	33 20       	and	r3, r3
 818:	19 f0       	breq	.+6      	; 0x820 <__stack+0x3c1>
 81a:	82 b7       	in	r24, 0x32	; 50
 81c:	83 19       	sub	r24, r3
 81e:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 820:	82 b7       	in	r24, 0x32	; 50

		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
 822:	8f 70       	andi	r24, 0x0F	; 15
 824:	8a 30       	cpi	r24, 0x0A	; 10
 826:	e1 f7       	brne	.-8      	; 0x820 <__stack+0x3c1>
 828:	14 c0       	rjmp	.+40     	; 0x852 <__stack+0x3f3>
		} else {
			wait_synced_on_rising_edge();	
 82a:	33 24       	eor	r3, r3
 82c:	05 c0       	rjmp	.+10     	; 0x838 <__stack+0x3d9>
 82e:	87 9b       	sbis	0x10, 7	; 16
 830:	03 c0       	rjmp	.+6      	; 0x838 <__stack+0x3d9>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 832:	82 b7       	in	r24, 0x32	; 50
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
		} else {
			wait_synced_on_rising_edge();	
 834:	38 2e       	mov	r3, r24
 836:	04 c0       	rjmp	.+8      	; 0x840 <__stack+0x3e1>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 838:	82 b7       	in	r24, 0x32	; 50
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
		} else {
			wait_synced_on_rising_edge();	
 83a:	8f 70       	andi	r24, 0x0F	; 15
 83c:	89 30       	cpi	r24, 0x09	; 9
 83e:	b9 f7       	brne	.-18     	; 0x82e <__stack+0x3cf>
 840:	33 20       	and	r3, r3
 842:	19 f0       	breq	.+6      	; 0x84a <__stack+0x3eb>
 844:	82 b7       	in	r24, 0x32	; 50
 846:	83 19       	sub	r24, r3
 848:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 84a:	82 b7       	in	r24, 0x32	; 50
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x10;	
			crc_add_1();
			wait_synced_on_falling_edge();	
		} else {
			wait_synced_on_rising_edge();	
 84c:	8f 70       	andi	r24, 0x0F	; 15
 84e:	8a 30       	cpi	r24, 0x0A	; 10
 850:	e1 f7       	brne	.-8      	; 0x84a <__stack+0x3eb>
		}
		crc_proceed_bit();
 852:	57 fe       	sbrs	r5, 7
 854:	02 c0       	rjmp	.+4      	; 0x85a <__stack+0x3fb>
 856:	50 26       	eor	r5, r16
 858:	4f 24       	eor	r4, r15
 85a:	88 94       	clc
 85c:	44 1c       	adc	r4, r4
 85e:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 860:	82 b7       	in	r24, 0x32	; 50
		// two zeroes are possible here in case of arbitration procedure
		//we_do_not_need_this_bit = get_rxd_value();

		// lower 4-bits
		// get NRZ bits
		if (sample_rxd_value()) {
 862:	8f 70       	andi	r24, 0x0F	; 15
 864:	89 30       	cpi	r24, 0x09	; 9
 866:	e1 f7       	brne	.-8      	; 0x860 <__stack+0x401>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 868:	82 b7       	in	r24, 0x32	; 50
		// two zeroes are possible here in case of arbitration procedure
		//we_do_not_need_this_bit = get_rxd_value();

		// lower 4-bits
		// get NRZ bits
		if (sample_rxd_value()) {
 86a:	8f 70       	andi	r24, 0x0F	; 15
 86c:	8a 30       	cpi	r24, 0x0A	; 10
 86e:	e1 f7       	brne	.-8      	; 0x868 <__stack+0x409>
 870:	87 9b       	sbis	0x10, 7	; 16
 872:	04 c0       	rjmp	.+8      	; 0x87c <__stack+0x41d>
			rxb_cur_byte |= (uint8_t)0x08;
 874:	88 e0       	ldi	r24, 0x08	; 8
 876:	28 2a       	or	r2, r24
			crc_add_1();
 878:	80 e8       	ldi	r24, 0x80	; 128
 87a:	58 0e       	add	r5, r24
		}
		crc_proceed_bit();
 87c:	57 fe       	sbrs	r5, 7
 87e:	02 c0       	rjmp	.+4      	; 0x884 <__stack+0x425>
 880:	50 26       	eor	r5, r16
 882:	4f 24       	eor	r4, r15
 884:	88 94       	clc
 886:	44 1c       	adc	r4, r4
 888:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 88a:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x08;
			crc_add_1();
		}
		crc_proceed_bit();
			
		if (sample_rxd_value()) {
 88c:	8f 70       	andi	r24, 0x0F	; 15
 88e:	89 30       	cpi	r24, 0x09	; 9
 890:	e1 f7       	brne	.-8      	; 0x88a <__stack+0x42b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 892:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x08;
			crc_add_1();
		}
		crc_proceed_bit();
			
		if (sample_rxd_value()) {
 894:	8f 70       	andi	r24, 0x0F	; 15
 896:	8a 30       	cpi	r24, 0x0A	; 10
 898:	e1 f7       	brne	.-8      	; 0x892 <__stack+0x433>
 89a:	87 9b       	sbis	0x10, 7	; 16
 89c:	04 c0       	rjmp	.+8      	; 0x8a6 <__stack+0x447>
			rxb_cur_byte |= (uint8_t)0x04;
 89e:	84 e0       	ldi	r24, 0x04	; 4
 8a0:	28 2a       	or	r2, r24
			crc_add_1();
 8a2:	80 e8       	ldi	r24, 0x80	; 128
 8a4:	58 0e       	add	r5, r24
		}
		crc_proceed_bit();
 8a6:	57 fe       	sbrs	r5, 7
 8a8:	02 c0       	rjmp	.+4      	; 0x8ae <__stack+0x44f>
 8aa:	50 26       	eor	r5, r16
 8ac:	4f 24       	eor	r4, r15
 8ae:	88 94       	clc
 8b0:	44 1c       	adc	r4, r4
 8b2:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 8b4:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x04;
			crc_add_1();
		}
		crc_proceed_bit();
		
		if (sample_rxd_value()) {
 8b6:	8f 70       	andi	r24, 0x0F	; 15
 8b8:	89 30       	cpi	r24, 0x09	; 9
 8ba:	e1 f7       	brne	.-8      	; 0x8b4 <__stack+0x455>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 8bc:	82 b7       	in	r24, 0x32	; 50
			rxb_cur_byte |= (uint8_t)0x04;
			crc_add_1();
		}
		crc_proceed_bit();
		
		if (sample_rxd_value()) {
 8be:	8f 70       	andi	r24, 0x0F	; 15
 8c0:	8a 30       	cpi	r24, 0x0A	; 10
 8c2:	e1 f7       	brne	.-8      	; 0x8bc <__stack+0x45d>
 8c4:	87 9b       	sbis	0x10, 7	; 16
 8c6:	04 c0       	rjmp	.+8      	; 0x8d0 <__stack+0x471>
			rxb_cur_byte |= (uint8_t)0x02;
 8c8:	82 e0       	ldi	r24, 0x02	; 2
 8ca:	28 2a       	or	r2, r24
			crc_add_1();
 8cc:	80 e8       	ldi	r24, 0x80	; 128
 8ce:	58 0e       	add	r5, r24
		}
		crc_proceed_bit();
 8d0:	57 fe       	sbrs	r5, 7
 8d2:	02 c0       	rjmp	.+4      	; 0x8d8 <__stack+0x479>
 8d4:	50 26       	eor	r5, r16
 8d6:	4f 24       	eor	r4, r15
 8d8:	88 94       	clc
 8da:	44 1c       	adc	r4, r4
 8dc:	55 1c       	adc	r5, r5
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 8de:	82 b7       	in	r24, 0x32	; 50
			crc_add_1();
		}
		crc_proceed_bit();

		// get MAN 1st TS
		if (sample_rxd_value()) {
 8e0:	8f 70       	andi	r24, 0x0F	; 15
 8e2:	89 30       	cpi	r24, 0x09	; 9
 8e4:	e1 f7       	brne	.-8      	; 0x8de <__stack+0x47f>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 8e6:	82 b7       	in	r24, 0x32	; 50
			crc_add_1();
		}
		crc_proceed_bit();

		// get MAN 1st TS
		if (sample_rxd_value()) {
 8e8:	8f 70       	andi	r24, 0x0F	; 15
 8ea:	8a 30       	cpi	r24, 0x0A	; 10
 8ec:	e1 f7       	brne	.-8      	; 0x8e6 <__stack+0x487>
 8ee:	87 9b       	sbis	0x10, 7	; 16
 8f0:	1b c0       	rjmp	.+54     	; 0x928 <__stack+0x4c9>
			rxb_cur_byte |= (uint8_t)0x01;
 8f2:	81 e0       	ldi	r24, 0x01	; 1
 8f4:	28 2a       	or	r2, r24
			crc_add_1();
 8f6:	80 e8       	ldi	r24, 0x80	; 128
 8f8:	58 0e       	add	r5, r24
			// get MAN 2nd TS, sync on it
			wait_synced_on_falling_edge();
 8fa:	33 24       	eor	r3, r3
 8fc:	05 c0       	rjmp	.+10     	; 0x908 <__stack+0x4a9>
 8fe:	87 99       	sbic	0x10, 7	; 16
 900:	03 c0       	rjmp	.+6      	; 0x908 <__stack+0x4a9>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 902:	82 b7       	in	r24, 0x32	; 50
		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x01;
			crc_add_1();
			// get MAN 2nd TS, sync on it
			wait_synced_on_falling_edge();
 904:	38 2e       	mov	r3, r24
 906:	04 c0       	rjmp	.+8      	; 0x910 <__stack+0x4b1>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 908:	82 b7       	in	r24, 0x32	; 50
		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x01;
			crc_add_1();
			// get MAN 2nd TS, sync on it
			wait_synced_on_falling_edge();
 90a:	8f 70       	andi	r24, 0x0F	; 15
 90c:	89 30       	cpi	r24, 0x09	; 9
 90e:	b9 f7       	brne	.-18     	; 0x8fe <__stack+0x49f>
 910:	33 20       	and	r3, r3
 912:	19 f0       	breq	.+6      	; 0x91a <__stack+0x4bb>
 914:	82 b7       	in	r24, 0x32	; 50
 916:	83 19       	sub	r24, r3
 918:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 91a:	82 b7       	in	r24, 0x32	; 50
		// get MAN 1st TS
		if (sample_rxd_value()) {
			rxb_cur_byte |= (uint8_t)0x01;
			crc_add_1();
			// get MAN 2nd TS, sync on it
			wait_synced_on_falling_edge();
 91c:	8f 70       	andi	r24, 0x0F	; 15
 91e:	8a 30       	cpi	r24, 0x0A	; 10
 920:	e1 f7       	brne	.-8      	; 0x91a <__stack+0x4bb>
			if (get_rxd_value() != 0) 
 922:	87 9b       	sbis	0x10, 7	; 16
 924:	17 c0       	rjmp	.+46     	; 0x954 <__stack+0x4f5>
 926:	30 c0       	rjmp	.+96     	; 0x988 <__stack+0x529>
				goto go_break; // not a EOD, but error
		} else {
			// get MAN 2nd TS and check for EOD marker
			wait_synced_on_rising_edge();
 928:	33 24       	eor	r3, r3
 92a:	05 c0       	rjmp	.+10     	; 0x936 <__stack+0x4d7>
 92c:	87 9b       	sbis	0x10, 7	; 16
 92e:	03 c0       	rjmp	.+6      	; 0x936 <__stack+0x4d7>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 930:	82 b7       	in	r24, 0x32	; 50
			wait_synced_on_falling_edge();
			if (get_rxd_value() != 0) 
				goto go_break; // not a EOD, but error
		} else {
			// get MAN 2nd TS and check for EOD marker
			wait_synced_on_rising_edge();
 932:	38 2e       	mov	r3, r24
 934:	04 c0       	rjmp	.+8      	; 0x93e <__stack+0x4df>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 936:	82 b7       	in	r24, 0x32	; 50
			wait_synced_on_falling_edge();
			if (get_rxd_value() != 0) 
				goto go_break; // not a EOD, but error
		} else {
			// get MAN 2nd TS and check for EOD marker
			wait_synced_on_rising_edge();
 938:	8f 70       	andi	r24, 0x0F	; 15
 93a:	89 30       	cpi	r24, 0x09	; 9
 93c:	b9 f7       	brne	.-18     	; 0x92c <__stack+0x4cd>
 93e:	33 20       	and	r3, r3
 940:	19 f0       	breq	.+6      	; 0x948 <__stack+0x4e9>
 942:	82 b7       	in	r24, 0x32	; 50
 944:	83 19       	sub	r24, r3
 946:	82 bf       	out	0x32, r24	; 50
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 948:	82 b7       	in	r24, 0x32	; 50
			wait_synced_on_falling_edge();
			if (get_rxd_value() != 0) 
				goto go_break; // not a EOD, but error
		} else {
			// get MAN 2nd TS and check for EOD marker
			wait_synced_on_rising_edge();
 94a:	8f 70       	andi	r24, 0x0F	; 15
 94c:	8a 30       	cpi	r24, 0x0A	; 10
 94e:	e1 f7       	brne	.-8      	; 0x948 <__stack+0x4e9>
			if (get_rxd_value() == 0) 
 950:	87 9b       	sbis	0x10, 7	; 16
 952:	1a c0       	rjmp	.+52     	; 0x988 <__stack+0x529>
				goto go_break;	
		}
		crc_proceed_bit();
 954:	57 fe       	sbrs	r5, 7
 956:	02 c0       	rjmp	.+4      	; 0x95c <__stack+0x4fd>
 958:	50 26       	eor	r5, r16
 95a:	4f 24       	eor	r4, r15
 95c:	88 94       	clc
 95e:	44 1c       	adc	r4, r4
 960:	55 1c       	adc	r5, r5


		*rxb_byte_ptr = rxb_cur_byte;
 962:	e0 91 60 03 	lds	r30, 0x0360
 966:	f0 91 61 03 	lds	r31, 0x0361
 96a:	20 82       	st	Z, r2
		++ rxb_byte_ptr;
 96c:	80 91 60 03 	lds	r24, 0x0360
 970:	90 91 61 03 	lds	r25, 0x0361
 974:	01 96       	adiw	r24, 0x01	; 1
 976:	90 93 61 03 	sts	0x0361, r25
 97a:	80 93 60 03 	sts	0x0360, r24

	// reserve room for msg length
	s_ptr = rxb_byte_ptr;
	++rxb_byte_ptr;

	for (i=0; i<32; i++) { // do not allow to overflow buffer
 97e:	2f 5f       	subi	r18, 0xFF	; 255
 980:	20 32       	cpi	r18, 0x20	; 32
 982:	09 f0       	breq	.+2      	; 0x986 <__stack+0x527>
 984:	f0 ce       	rjmp	.-544    	; 0x766 <__stack+0x307>
 986:	15 c0       	rjmp	.+42     	; 0x9b2 <__stack+0x553>

		*rxb_byte_ptr = rxb_cur_byte;
		++ rxb_byte_ptr;
		continue;
go_break:
		crc_proceed_bit(); // not sure it is required here, may be we just need check crc here?
 988:	57 fe       	sbrs	r5, 7
 98a:	02 c0       	rjmp	.+4      	; 0x990 <__stack+0x531>
 98c:	50 26       	eor	r5, r16
 98e:	4f 24       	eor	r4, r15
 990:	88 94       	clc
 992:	44 1c       	adc	r4, r4
 994:	55 1c       	adc	r5, r5
		*rxb_byte_ptr = rxb_cur_byte;
 996:	e0 91 60 03 	lds	r30, 0x0360
 99a:	f0 91 61 03 	lds	r31, 0x0361
 99e:	20 82       	st	Z, r2
		++ rxb_byte_ptr;
 9a0:	80 91 60 03 	lds	r24, 0x0360
 9a4:	90 91 61 03 	lds	r25, 0x0361
 9a8:	01 96       	adiw	r24, 0x01	; 1
 9aa:	90 93 61 03 	sts	0x0361, r25
 9ae:	80 93 60 03 	sts	0x0360, r24
		break;
	}

	// now, receive 2 last ACK bits, if any

	rxb_cur_byte = 0;
 9b2:	22 24       	eor	r2, r2
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9b4:	82 b7       	in	r24, 0x32	; 50

	// now, receive 2 last ACK bits, if any

	rxb_cur_byte = 0;

	if (sample_rxd_value()) 
 9b6:	8f 70       	andi	r24, 0x0F	; 15
 9b8:	89 30       	cpi	r24, 0x09	; 9
 9ba:	e1 f7       	brne	.-8      	; 0x9b4 <__stack+0x555>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9bc:	82 b7       	in	r24, 0x32	; 50

	// now, receive 2 last ACK bits, if any

	rxb_cur_byte = 0;

	if (sample_rxd_value()) 
 9be:	8f 70       	andi	r24, 0x0F	; 15
 9c0:	8a 30       	cpi	r24, 0x0A	; 10
 9c2:	e1 f7       	brne	.-8      	; 0x9bc <__stack+0x55d>
 9c4:	87 9b       	sbis	0x10, 7	; 16
 9c6:	02 c0       	rjmp	.+4      	; 0x9cc <__stack+0x56d>
		rxb_cur_byte |= (uint8_t)0x80;
 9c8:	20 e8       	ldi	r18, 0x80	; 128
 9ca:	22 2e       	mov	r2, r18
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9cc:	82 b7       	in	r24, 0x32	; 50

	rxb_cur_byte = 0;

	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x80;
	if (sample_rxd_value()) 
 9ce:	8f 70       	andi	r24, 0x0F	; 15
 9d0:	89 30       	cpi	r24, 0x09	; 9
 9d2:	e1 f7       	brne	.-8      	; 0x9cc <__stack+0x56d>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9d4:	82 b7       	in	r24, 0x32	; 50

	rxb_cur_byte = 0;

	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x80;
	if (sample_rxd_value()) 
 9d6:	8f 70       	andi	r24, 0x0F	; 15
 9d8:	8a 30       	cpi	r24, 0x0A	; 10
 9da:	e1 f7       	brne	.-8      	; 0x9d4 <__stack+0x575>
 9dc:	87 9b       	sbis	0x10, 7	; 16
 9de:	02 c0       	rjmp	.+4      	; 0x9e4 <__stack+0x585>
		rxb_cur_byte |= (uint8_t)0x40;
 9e0:	20 e4       	ldi	r18, 0x40	; 64
 9e2:	22 2a       	or	r2, r18
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9e4:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x80;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x40;
	
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
 9e6:	8f 70       	andi	r24, 0x0F	; 15
 9e8:	89 30       	cpi	r24, 0x09	; 9
 9ea:	e1 f7       	brne	.-8      	; 0x9e4 <__stack+0x585>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9ec:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x80;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x40;
	
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
 9ee:	8f 70       	andi	r24, 0x0F	; 15
 9f0:	8a 30       	cpi	r24, 0x0A	; 10
 9f2:	e1 f7       	brne	.-8      	; 0x9ec <__stack+0x58d>
 9f4:	87 9b       	sbis	0x10, 7	; 16
 9f6:	02 c0       	rjmp	.+4      	; 0x9fc <__stack+0x59d>
		rxb_cur_byte |= (uint8_t)0x20;
 9f8:	80 e2       	ldi	r24, 0x20	; 32
 9fa:	28 2a       	or	r2, r24
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 9fc:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x40;
	
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
 9fe:	8f 70       	andi	r24, 0x0F	; 15
 a00:	89 30       	cpi	r24, 0x09	; 9
 a02:	e1 f7       	brne	.-8      	; 0x9fc <__stack+0x59d>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 a04:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x40;
	
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
 a06:	8f 70       	andi	r24, 0x0F	; 15
 a08:	8a 30       	cpi	r24, 0x0A	; 10
 a0a:	e1 f7       	brne	.-8      	; 0xa04 <__stack+0x5a5>
 a0c:	87 9b       	sbis	0x10, 7	; 16
 a0e:	02 c0       	rjmp	.+4      	; 0xa14 <__stack+0x5b5>
		rxb_cur_byte |= (uint8_t)0x10;
 a10:	20 e1       	ldi	r18, 0x10	; 16
 a12:	22 2a       	or	r2, r18
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 a14:	82 b7       	in	r24, 0x32	; 50
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x10;
	if (sample_rxd_value()) 
 a16:	8f 70       	andi	r24, 0x0F	; 15
 a18:	89 30       	cpi	r24, 0x09	; 9
 a1a:	e1 f7       	brne	.-8      	; 0xa14 <__stack+0x5b5>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 a1c:	82 b7       	in	r24, 0x32	; 50
	// sample some more bits, for debugging
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x10;
	if (sample_rxd_value()) 
 a1e:	8f 70       	andi	r24, 0x0F	; 15
 a20:	8a 30       	cpi	r24, 0x0A	; 10
 a22:	e1 f7       	brne	.-8      	; 0xa1c <__stack+0x5bd>
 a24:	87 9b       	sbis	0x10, 7	; 16
 a26:	02 c0       	rjmp	.+4      	; 0xa2c <__stack+0x5cd>
		rxb_cur_byte |= (uint8_t)0x08;
 a28:	88 e0       	ldi	r24, 0x08	; 8
 a2a:	28 2a       	or	r2, r24
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 a2c:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x10;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x08;
	if (sample_rxd_value()) 
 a2e:	8f 70       	andi	r24, 0x0F	; 15
 a30:	89 30       	cpi	r24, 0x09	; 9
 a32:	e1 f7       	brne	.-8      	; 0xa2c <__stack+0x5cd>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 a34:	82 b7       	in	r24, 0x32	; 50
		rxb_cur_byte |= (uint8_t)0x20;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x10;
	if (sample_rxd_value()) 
		rxb_cur_byte |= (uint8_t)0x08;
	if (sample_rxd_value()) 
 a36:	8f 70       	andi	r24, 0x0F	; 15
 a38:	8a 30       	cpi	r24, 0x0A	; 10
 a3a:	e1 f7       	brne	.-8      	; 0xa34 <__stack+0x5d5>
 a3c:	87 9b       	sbis	0x10, 7	; 16
 a3e:	02 c0       	rjmp	.+4      	; 0xa44 <__stack+0x5e5>
		rxb_cur_byte |= (uint8_t)0x04;
 a40:	24 e0       	ldi	r18, 0x04	; 4
 a42:	22 2a       	or	r2, r18

	// verify crc and add 'crc-valid' marker
	if (CRC_VALID())
 a44:	83 e3       	ldi	r24, 0x33	; 51
 a46:	58 16       	cp	r5, r24
 a48:	31 f4       	brne	.+12     	; 0xa56 <__stack+0x5f7>
 a4a:	2e e6       	ldi	r18, 0x6E	; 110
 a4c:	42 16       	cp	r4, r18
 a4e:	19 f4       	brne	.+6      	; 0xa56 <__stack+0x5f7>
		rxb_cur_byte |= (uint8_t) 0x02;
 a50:	82 e0       	ldi	r24, 0x02	; 2
 a52:	28 2a       	or	r2, r24
 a54:	02 c0       	rjmp	.+4      	; 0xa5a <__stack+0x5fb>
	else
		rxb_cur_byte |= (uint8_t) 0x01;
 a56:	21 e0       	ldi	r18, 0x01	; 1
 a58:	22 2a       	or	r2, r18

	*rxb_byte_ptr = rxb_cur_byte;
 a5a:	e0 91 60 03 	lds	r30, 0x0360
 a5e:	f0 91 61 03 	lds	r31, 0x0361
 a62:	20 82       	st	Z, r2
	// reset bit ptr for next msg, increase byte write ptr
	++ rxb_byte_ptr;
 a64:	80 91 60 03 	lds	r24, 0x0360
 a68:	90 91 61 03 	lds	r25, 0x0361
 a6c:	01 96       	adiw	r24, 0x01	; 1
 a6e:	90 93 61 03 	sts	0x0361, r25
 a72:	80 93 60 03 	sts	0x0360, r24

	*s_ptr = rxb_byte_ptr - s_ptr -1;
 a76:	8a 1b       	sub	r24, r26
 a78:	81 50       	subi	r24, 0x01	; 1
 a7a:	8c 93       	st	X, r24

	if (rxb_byte_ptr-&rxb[0] > RX_BUFFER_SIZE - 50) {
 a7c:	80 91 60 03 	lds	r24, 0x0360
 a80:	90 91 61 03 	lds	r25, 0x0361
 a84:	80 56       	subi	r24, 0x60	; 96
 a86:	90 40       	sbci	r25, 0x00	; 0
 a88:	8f 5c       	subi	r24, 0xCF	; 207
 a8a:	92 40       	sbci	r25, 0x02	; 2
 a8c:	0c f4       	brge	.+2      	; 0xa90 <__stack+0x631>
 a8e:	a9 cd       	rjmp	.-1198   	; 0x5e2 <__stack+0x183>
		send_captured();
 a90:	9d dc       	rcall	.-1734   	; 0x3cc <send_captured>
 a92:	a3 cd       	rjmp	.-1210   	; 0x5da <__stack+0x17b>
uint8_t tx_packet(const uint8_t *pkt, uint8_t len);


inline uint8_t check_reset() 
{
	return (USART_hasByte() && USART_vReceiveByte() == 'r');
 a94:	5f 9b       	sbis	0x0b, 7	; 11
 a96:	0a c0       	rjmp	.+20     	; 0xaac <__stack+0x64d>

uint8_t USART_vReceiveByte()
{
	uint8_t r;
	// Wait until a byte has been received
	while((UCSRA&(1<<RXC)) == 0) ;
 a98:	5f 9b       	sbis	0x0b, 7	; 11
 a9a:	fe cf       	rjmp	.-4      	; 0xa98 <__stack+0x639>
	// Return received data
	r = UDR;
 a9c:	8c b1       	in	r24, 0x0c	; 12
 a9e:	90 e0       	ldi	r25, 0x00	; 0
 aa0:	82 37       	cpi	r24, 0x72	; 114
 aa2:	09 f0       	breq	.+2      	; 0xaa6 <__stack+0x647>
 aa4:	91 e0       	ldi	r25, 0x01	; 1
	}
	goto wait_frame_start;


monitor_bus:
	if (check_reset() ) 
 aa6:	99 15       	cp	r25, r9
 aa8:	09 f0       	breq	.+2      	; 0xaac <__stack+0x64d>
 aaa:	07 cd       	rjmp	.-1522   	; 0x4ba <__stack+0x5b>
		goto reset;

	rxb_byte_ptr = &rxb[0];
 aac:	d0 92 61 03 	sts	0x0361, r13
 ab0:	c0 92 60 03 	sts	0x0360, r12
	TCNT0 = value;
}

inline void zero_timer0()
{
	TCNT0 = (uint8_t) 0;
 ab4:	12 be       	out	0x32, r1	; 50
	if (check_reset() ) 
		goto reset;

	rxb_byte_ptr = &rxb[0];
	zero_timer0();
	tmp_reg = get_rxd_value();
 ab6:	80 b3       	in	r24, 0x10	; 16
 ab8:	80 78       	andi	r24, 0x80	; 128
 aba:	38 2e       	mov	r3, r24
	*rxb_byte_ptr = tmp_reg; 
 abc:	80 93 60 00 	sts	0x0060, r24
	++rxb_byte_ptr;
 ac0:	70 92 61 03 	sts	0x0361, r7
 ac4:	60 92 60 03 	sts	0x0360, r6
 ac8:	1b c0       	rjmp	.+54     	; 0xb00 <__stack+0x6a1>
	while (rxb_byte_ptr != &rxb[RX_BUFFER_SIZE-1]) {
		while ((i = get_rxd_value()) == tmp_reg)  // wait for line to be changed 
 aca:	20 b3       	in	r18, 0x10	; 16
 acc:	20 78       	andi	r18, 0x80	; 128
 ace:	28 17       	cp	r18, r24
 ad0:	e1 f3       	breq	.-8      	; 0xaca <__stack+0x66b>
	TCCR0 = (uint8_t) (0 << CS02) | (1 << CS01) | (0 << CS00);
}

inline uint8_t get_timer0() 
{
	return TCNT0;
 ad2:	82 b7       	in	r24, 0x32	; 50
	*rxb_byte_ptr = tmp_reg; 
	++rxb_byte_ptr;
	while (rxb_byte_ptr != &rxb[RX_BUFFER_SIZE-1]) {
		while ((i = get_rxd_value()) == tmp_reg)  // wait for line to be changed 
			;
		*rxb_byte_ptr = get_timer0();
 ad4:	80 83       	st	Z, r24
		++rxb_byte_ptr;
 ad6:	80 91 60 03 	lds	r24, 0x0360
 ada:	90 91 61 03 	lds	r25, 0x0361
 ade:	01 96       	adiw	r24, 0x01	; 1
 ae0:	90 93 61 03 	sts	0x0361, r25
 ae4:	80 93 60 03 	sts	0x0360, r24
		tmp_reg = i;
 ae8:	32 2e       	mov	r3, r18
uint8_t tx_packet(const uint8_t *pkt, uint8_t len);


inline uint8_t check_reset() 
{
	return (USART_hasByte() && USART_vReceiveByte() == 'r');
 aea:	5f 9b       	sbis	0x0b, 7	; 11
 aec:	09 c0       	rjmp	.+18     	; 0xb00 <__stack+0x6a1>

uint8_t USART_vReceiveByte()
{
	uint8_t r;
	// Wait until a byte has been received
	while((UCSRA&(1<<RXC)) == 0) ;
 aee:	5f 9b       	sbis	0x0b, 7	; 11
 af0:	fe cf       	rjmp	.-4      	; 0xaee <__stack+0x68f>
	// Return received data
	r = UDR;
 af2:	8c b1       	in	r24, 0x0c	; 12
 af4:	90 e0       	ldi	r25, 0x00	; 0
 af6:	82 37       	cpi	r24, 0x72	; 114
 af8:	09 f0       	breq	.+2      	; 0xafc <__stack+0x69d>
 afa:	91 e0       	ldi	r25, 0x01	; 1
		while ((i = get_rxd_value()) == tmp_reg)  // wait for line to be changed 
			;
		*rxb_byte_ptr = get_timer0();
		++rxb_byte_ptr;
		tmp_reg = i;
		if (check_reset())
 afc:	99 15       	cp	r25, r9
 afe:	51 f4       	brne	.+20     	; 0xb14 <__stack+0x6b5>
	rxb_byte_ptr = &rxb[0];
	zero_timer0();
	tmp_reg = get_rxd_value();
	*rxb_byte_ptr = tmp_reg; 
	++rxb_byte_ptr;
	while (rxb_byte_ptr != &rxb[RX_BUFFER_SIZE-1]) {
 b00:	e0 91 60 03 	lds	r30, 0x0360
 b04:	f0 91 61 03 	lds	r31, 0x0361
 b08:	83 e0       	ldi	r24, 0x03	; 3
 b0a:	ef 35       	cpi	r30, 0x5F	; 95
 b0c:	f8 07       	cpc	r31, r24
 b0e:	11 f0       	breq	.+4      	; 0xb14 <__stack+0x6b5>
		while ((i = get_rxd_value()) == tmp_reg)  // wait for line to be changed 
 b10:	83 2d       	mov	r24, r3
 b12:	db cf       	rjmp	.-74     	; 0xaca <__stack+0x66b>
 b14:	c0 e6       	ldi	r28, 0x60	; 96
 b16:	d0 e0       	ldi	r29, 0x00	; 0
 b18:	02 c0       	rjmp	.+4      	; 0xb1e <__stack+0x6bf>
		if (check_reset())
			goto out_monitor_bus;
	}
out_monitor_bus:
	for (s_ptr=&rxb[0]; s_ptr < rxb_byte_ptr;  ++ s_ptr ) {
		show_hex(*s_ptr);
 b1a:	89 91       	ld	r24, Y+
 b1c:	42 dc       	rcall	.-1916   	; 0x3a2 <show_hex>
		tmp_reg = i;
		if (check_reset())
			goto out_monitor_bus;
	}
out_monitor_bus:
	for (s_ptr=&rxb[0]; s_ptr < rxb_byte_ptr;  ++ s_ptr ) {
 b1e:	80 91 60 03 	lds	r24, 0x0360
 b22:	90 91 61 03 	lds	r25, 0x0361
 b26:	c8 17       	cp	r28, r24
 b28:	d9 07       	cpc	r29, r25
 b2a:	b8 f3       	brcs	.-18     	; 0xb1a <__stack+0x6bb>
		show_hex(*s_ptr);
	}
	USART_sendCrLf();
 b2c:	aa db       	rcall	.-2220   	; 0x282 <USART_sendCrLf>
 b2e:	b2 cf       	rjmp	.-156    	; 0xa94 <__stack+0x635>

00000b30 <_exit>:
 b30:	f8 94       	cli

00000b32 <__stop_program>:
 b32:	ff cf       	rjmp	.-2      	; 0xb32 <__stop_program>
